var e,n,t,o,i;import{V as a,e as r,g as s,d as l,A as c,a as d,c as u,h,b as m,G as p,i as f,D as v,j as g,k as w,l as y,m as b,n as x,o as M,p as C,q as k,L as D,r as S,s as P,U as z,t as A,B as T,u as R,v as H,w as E,x as L,y as F,z as N,I as O,J as I,K as U,X as V,f as B,Y as j,Z as _,C as W,_ as G,$ as q,a0 as $,a1 as Y,a2 as K,a3 as X,a4 as Z,a5 as Q,a6 as J,a7 as ee}from"./three-core-hqvYzVHM.js";import{G as ne,S as te,s as oe,a as ie,b as ae}from"./vendor-snkDjmV2.js";import{O as re,S as se,E as le,R as ce,U as de}from"./three-addons-BTDtUzb1.js";!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))n(e);new MutationObserver(e=>{for(const t of e)if("childList"===t.type)for(const e of t.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&n(e)}).observe(document,{childList:!0,subtree:!0})}function n(e){if(e.ep)return;e.ep=!0;const n=function(e){const n={};return e.integrity&&(n.integrity=e.integrity),e.referrerPolicy&&(n.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?n.credentials="include":"anonymous"===e.crossOrigin?n.credentials="omit":n.credentials="same-origin",n}(e);fetch(e.href,n)}}();const ue=new a(500,0,500);new a(400,400,400);let he={};const me={uniforms:{uTime:{value:0},uSpeed:{value:1},uColor1:{value:null},uColor2:{value:null},uTailLength:{value:1},uBloomIntensity:{value:1}},vertexShader:"\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying float vLifeProgress;\n\n    void main() {\n      vUv = uv;\n      vPosition = position;\n      vLifeProgress = uv.x; // Kuyruk uzunluƒüu ge√ßi≈üi i√ßin\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    uniform float uTime;\n    uniform float uSpeed;\n    uniform float uTailLength;\n    uniform float uBloomIntensity;\n    uniform vec3 uColor1;\n    uniform vec3 uColor2;\n\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying float vLifeProgress;\n\n    // Basit bir g√ºr√ºlt√º fonksiyonu (placeholder)\n    float rand(vec2 co) {\n      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n\n    void main() {\n      vec2 noiseCoord = vPosition.xy * 2.0 + vec2(uTime * uSpeed * 0.5);\n      float noise = rand(noiseCoord) * 0.5 + 0.5;\n\n      float alpha = smoothstep(0.3, 0.7, noise);\n      float tailFade = smoothstep(uTailLength, 0.0, vLifeProgress);\n      alpha *= tailFade;\n\n      // üî• Siyah leke korumasƒ±\n      alpha = max(alpha, 0.05);\n\n      // Renk ge√ßi≈üi (√ßekirdekten kuyruƒüa)\n      vec3 coreColor = mix(uColor1, uColor2, alpha * 2.0);\n      vec3 finalColor = coreColor * (0.5 + 0.5 * alpha);\n\n      // Bloom etkisi ve fade\n      finalColor *= uBloomIntensity;\n      alpha *= 1.0 - smoothstep(0.8, 1.0, vLifeProgress);\n\n      gl_FragColor = vec4(finalColor, alpha * 0.9);\n    }\n  "};class pe{constructor(e,n,t){this.material=new l({uniforms:z.merge([me.uniforms,{uTime:{value:0},uSpeed:{value:t.speedBoost||1},uColor1:{value:new r(t.coreColor)},uColor2:{value:new r(t.tailColor)},uTailLength:{value:t.tailLength},uBloomIntensity:{value:t.bloomIntensity}}]),vertexShader:me.vertexShader,fragmentShader:me.fragmentShader,transparent:!0,depthWrite:!1,depthTest:!0,blending:c});const o=new A(.1,.5,5,8);o.rotateX(Math.PI),o.rotateY(Math.PI),this.mesh=new u(o,this.material);const i=m.randFloat(100,300),s=new a;n.getWorldDirection(s);const d=new a(0,1,0),h=(new a).crossVectors(s,d).normalize();d.crossVectors(h,s).normalize();const p=m.degToRad(m.randFloat(15,75)),f=m.randFloatSpread(Math.PI),v=(new a).addScaledVector(h,Math.cos(f)*Math.sin(p)).addScaledVector(d,Math.sin(f)*Math.sin(p)).addScaledVector(s,Math.cos(p)).normalize();this.mesh.position.copy(n.position).add(v.multiplyScalar(i));const g=m.randFloatSpread(360),w=t.baseSpeed;this.velocity=new a(Math.cos(g)*w*.5,.8*-w,Math.sin(g)*w*.5),this.mesh.quaternion.setFromUnitVectors(new a(0,1,0),this.velocity.clone().normalize()),this.lifespan=1.2,this.age=0,this.starParams=t,this.startTime=Date.now(),e.add(this.mesh)}update(e){var n;return this.age+=e,this.material.uniforms.uTime.value=.001*(Date.now()-this.startTime),this.material.uniforms.uTailLength.value=this.starParams.tailLength,this.material.uniforms.uBloomIntensity.value=this.starParams.bloomIntensity,this.material.uniforms.uColor1.value.set(this.starParams.coreColor),this.material.uniforms.uColor2.value.set(this.starParams.tailColor),this.mesh.position.add(this.velocity.clone().multiplyScalar(e)),this.mesh.updateMatrixWorld(),!(this.age>=this.lifespan)||(null==(n=this.mesh.parent)||n.remove(this.mesh),!1)}}class fe{constructor(){this.group=new k;const e=1e3,n=200,t=1e3,o=[5,20],i=[{color:new r(44783),weight:.02,name:"O - Mavi"},{color:new r(65519),weight:.05,name:"B - Mavi-Beyaz"},{color:new r(11193599),weight:.08,name:"A - Beyaz-Mavi"},{color:new r(16777215),weight:.15,name:"F - Saf Beyaz"},{color:new r(16772761),weight:.2,name:"G - Sarƒ± (G√ºne≈ü)"},{color:new r(16742212),weight:.25,name:"K - Turuncu"},{color:new r(16725828),weight:.25,name:"M - Kƒ±rmƒ±zƒ±"}],a=[];let s=0;for(const r of i)s+=r.weight,a.push(s);function d(){const e=Math.random();for(let n=0;n<a.length;n++)if(e<=a[n])return i[n].color;return i[i.length-1].color}const u=new Float32Array(3*e),h=new Float32Array(e),p=new Float32Array(3*e);for(let r=0;r<e;r++){const e=m.lerp(n,t,Math.random()),i=2*Math.random()*Math.PI,a=Math.acos(2*Math.random()-1);u[3*r]=e*Math.sin(a)*Math.cos(i),u[3*r+1]=e*Math.sin(a)*Math.sin(i),u[3*r+2]=e*Math.cos(a),h[r]=m.lerp(o[0],o[1],Math.random());const s=d();p[3*r]=s.r,p[3*r+1]=s.g,p[3*r+2]=s.b}const f=new T;f.setAttribute("position",new R(u,3)),f.setAttribute("size",new R(h,1)),f.setAttribute("color",new R(p,3));const v=new l({uniforms:{pixelRatio:{value:window.devicePixelRatio}},vertexShader:"\n        attribute float size;\n        attribute vec3 color;\n        uniform float pixelRatio;\n        \n        varying vec3 vColor;\n        varying float vSize;\n        \n        void main() {\n          vColor = color;\n          vSize = size;\n          \n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          \n          // Mesafeye g√∂re boyut ayarla (perspektif)\n          gl_PointSize = size * pixelRatio * (300.0 / -mvPosition.z);\n          gl_PointSize = clamp(gl_PointSize, 1.0, 20.0);\n          \n          gl_Position = projectionMatrix * mvPosition;\n        }\n      ",fragmentShader:"\n        varying vec3 vColor;\n        varying float vSize;\n        \n        void main() {\n          vec2 center = gl_PointCoord - 0.5;\n          float dist = length(center) * 2.0;\n          \n          // üåü G√ú√áL√ú FAKE GLOW - 3 katmanlƒ±\n          \n          // 1. Parlak √ßekirdek (core)\n          float core = 1.0 - smoothstep(0.0, 0.3, dist);\n          \n          // 2. ƒ∞√ß glow\n          float innerGlow = 1.0 - smoothstep(0.0, 0.6, dist);\n          innerGlow = pow(innerGlow, 2.0) * 0.8;\n          \n          // 3. Dƒ±≈ü glow (yumu≈üak hale)\n          float outerGlow = 1.0 - smoothstep(0.0, 1.0, dist);\n          outerGlow = pow(outerGlow, 3.0) * 0.4;\n          \n          // Toplam parlaklƒ±k\n          float brightness = core + innerGlow + outerGlow;\n          \n          // Alpha - dƒ±≈ü glow i√ßin daha geni≈ü\n          float alpha = 1.0 - smoothstep(0.3, 1.0, dist);\n          alpha = max(alpha, outerGlow * 0.5);\n          \n          if (alpha < 0.01) discard;\n          \n          // √áekirdek beyaza yakla≈üsƒ±n (sƒ±cak yƒ±ldƒ±z efekti)\n          vec3 coreColor = mix(vColor, vec3(1.0), core * 0.5);\n          \n          gl_FragColor = vec4(coreColor * brightness, alpha);\n        }\n      ",transparent:!0,depthWrite:!1,blending:c}),g=new H(f,v);this.group.add(g),this.points=g,this.material=v}update(e=1e-4,n=.016){this.group.rotation.y+=e}}class ve{constructor(e,n,t={},o=null){if(this.scene=e,this.config={size:t.size||1200,coreColor:t.coreColor||new r(12753151),innerColor1:t.innerColor1||new r(65535),innerColor2:t.innerColor2||new r(65416),midColor1:t.midColor1||new r(16737792),midColor2:t.midColor2||new r(16711816),outerColor:t.outerColor||new r(8913151),layers:t.layers||4,brightness:t.brightness||1.5,coreIntensity:t.coreIntensity||1.8,filamentDetail:t.filamentDetail||3,animated:!1!==t.animated,...t},this.group=new k,this.group.position.copy(n),o){const e=new a;e.subVectors(o.position,n),e.y=0,e.normalize(),this.group.rotation.y=Math.atan2(e.x,e.z)}this.textureLoader=new M,this.alphaMasks=[],this.masksLoaded=!1,this.maskPaths=["/textures/dense.jpg","/textures/medium_dense.jpg","/textures/medium_sparse.jpg","/textures/sparse.jpg"],this.layers=[],this.loadMasksAndCreateNebula(),e.add(this.group)}loadMasksAndCreateNebula(){let e=0;this.maskPaths.forEach((n,t)=>{this.textureLoader.load(n,n=>{n.wrapS=F,n.wrapT=F,n.minFilter=S,n.magFilter=S,this.alphaMasks[t]=n,e++,e===this.maskPaths.length&&(this.masksLoaded=!0,this.createNebula())},void 0,n=>{e++,e===this.maskPaths.length&&(this.masksLoaded=!0,this.createNebula())})})}createNebula(){this.layerSpacing=150+150*Math.random();for(let e=0;e<this.config.layers;e++){const n=this.createNebulaLayer(e);this.layers.push(n),this.group.add(n)}}createNebulaLayer(e){const n=this.config.size*(1+.3*e),t=new h(n,n,1,1),o={time:{value:0},coreColor:{value:this.config.coreColor},innerColor1:{value:this.config.innerColor1},innerColor2:{value:this.config.innerColor2},midColor1:{value:this.config.midColor1},midColor2:{value:this.config.midColor2},outerColor:{value:this.config.outerColor},brightness:{value:this.config.brightness},coreIntensity:{value:this.config.coreIntensity},filamentDetail:{value:this.config.filamentDetail},seed:{value:100*Math.random()},layerOffset:{value:.5*e},layerDepth:{value:e/this.config.layers},opacity:{value:.8/(e+1)},alphaMap:{value:this.alphaMasks[e]||null},useAlphaMap:{value:this.alphaMasks[e]?1:0}},i=new l({uniforms:o,vertexShader:"\n        varying vec2 vUv;\n        \n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        uniform float time;\n        uniform vec3 coreColor;\n        uniform vec3 innerColor1;\n        uniform vec3 innerColor2;\n        uniform vec3 midColor1;\n        uniform vec3 midColor2;\n        uniform vec3 outerColor;\n        uniform float brightness;\n        uniform float coreIntensity;\n        uniform float filamentDetail;\n        uniform float seed;\n        uniform float layerOffset;\n        uniform float layerDepth;\n        uniform float opacity;\n        uniform sampler2D alphaMap;        // √∞≈∏≈Ω¬≠ ALPHA MASK TEXTURE\n        uniform float useAlphaMap;         // √∞≈∏≈Ω¬≠ ALPHA MASK KULLANIM FLAG\n        \n        varying vec2 vUv;\n        \n        // ========================================\n        // MAIN SHADER (MASK-ONLY MODE)\n        // ========================================\n        \n        void main() {\n          vec2 center = vUv - 0.5;\n          float dist = length(center);\n          \n          // 1√Ø¬∏¬è√¢∆í¬£ MASK DE√Ñ≈æER√Ñ¬∞N√Ñ¬∞ AL (e√Ñ≈∏er varsa)\n          float maskValue = 1.0;\n          if (useAlphaMap > 0.5) {\n            maskValue = texture2D(alphaMap, vUv).r;\n          }\n          \n          // 2√Ø¬∏¬è√¢∆í¬£ RADIAL FALLOFF (sadece kenar yumu√Ö≈∏atma i√É¬ßin)\n          float radialMask = 1.0 - smoothstep(0.45, 0.5, dist);\n          \n          // 3√Ø¬∏¬è√¢∆í¬£ ANIMASYON ZAMANI (sadece hafif hareket i√É¬ßin)\n          float t = time * 0.02 + layerOffset;\n          \n          // 4√Ø¬∏¬è√¢∆í¬£ PARLAK √É‚Ä°EK√Ñ¬∞RDEK B√É‚ÄìLGE (√É¬ßok hafif)\n          float coreMask = 1.0 - smoothstep(0.0, 0.2, dist);\n          float coreGlow = pow(coreMask, 4.0) * coreIntensity * 0.3; // Azalt√Ñ¬±ld√Ñ¬±\n          \n          // 5√Ø¬∏¬è√¢∆í¬£ RENK GRADYANI (sadece mesafeye g√É¬∂re)\n          vec3 nebulaColor;\n          \n          // Merkez -> D√Ñ¬±√Ö≈∏ renk ge√É¬ßi√Ö≈∏i\n          if (dist < 0.1) {\n            // √É‚Ä°ekirdek: Beyaz\n            nebulaColor = coreColor;\n          } else if (dist < 0.2) {\n            // √Ñ¬∞√É¬ß b√É¬∂lge: Beyaz -> Cyan\n            float t = (dist - 0.1) / 0.1;\n            nebulaColor = mix(coreColor, innerColor1, t);\n          } else if (dist < 0.3) {\n            // √Ñ¬∞√É¬ß-orta: Cyan -> Ye√Ö≈∏il-mavi\n            float t = (dist - 0.2) / 0.1;\n            nebulaColor = mix(innerColor1, innerColor2, t);\n          } else if (dist < 0.4) {\n            // Orta: Ye√Ö≈∏il-mavi -> Turuncu\n            float t = (dist - 0.3) / 0.1;\n            nebulaColor = mix(innerColor2, midColor1, t);\n          } else if (dist < 0.5) {\n            // Orta-d√Ñ¬±√Ö≈∏: Turuncu -> Pembe\n            float t = (dist - 0.4) / 0.1;\n            nebulaColor = mix(midColor1, midColor2, t);\n          } else {\n            // D√Ñ¬±√Ö≈∏: Pembe -> Mor\n            float t = (dist - 0.5) / 0.05;\n            nebulaColor = mix(midColor2, outerColor, clamp(t, 0.0, 1.0));\n          }\n          \n          // 6√Ø¬∏¬è√¢∆í¬£ MASK √Ñ¬∞LE RENG√Ñ¬∞ MOD√É≈ìLE ET\n          // Mask de√Ñ≈∏eri parlakl√Ñ¬±√Ñ≈∏√Ñ¬± belirler\n          float intensity = maskValue * brightness;\n          \n          // 7√Ø¬∏¬è√¢∆í¬£ √É‚Ä°EKIRDEK GLOW EKLEN√Ñ¬∞YOR (√É¬ßok hafif)\n          nebulaColor += coreColor * coreGlow * maskValue;\n          \n          // 8√Ø¬∏¬è√¢∆í¬£ EDGE FADE (kenarlar yumu√Ö≈∏ak)\n          float edgeFade = smoothstep(0.0, 0.05, radialMask);\n          \n          // 9√Ø¬∏¬è√¢∆í¬£ FINAL ALPHA\n          float alpha = intensity * opacity * edgeFade * radialMask;\n          alpha = clamp(alpha, 0.0, 1.0);\n          \n          gl_FragColor = vec4(nebulaColor * intensity, alpha);\n        }\n      ",transparent:!0,depthWrite:!1,blending:U,blendEquation:I,blendSrc:O,blendDst:N,side:E}),a=new u(t,i);return a.rotation.z=e*Math.PI*.6/this.config.layers,a.position.z=(e-this.config.layers/2)*this.layerSpacing,a}update(e,n){if(!this.config.animated)return;let t=!1;const o=this.layers.map((e,t)=>{const o=new a;e.getWorldPosition(o);return{layer:e,index:t,distance:n.position.distanceTo(o)}});o.sort((e,n)=>e.distance-n.distance),o.forEach((n,o)=>{const{layer:i,index:a,distance:r}=n;i.material.uniforms.time.value+=e,i.rotation.z+=.01*e*(1+.2*a);const s=2500+150*o,l=800+150*o;let c=0;if(r<=l)c=1;else if(r<s){c=1-(r-l)/(s-l)}c>0&&c<1&&(c=c<.5?4*c*c*c:1-Math.pow(-2*c+2,3)/2);const d=c*(.8/(a+1));i.material.uniforms.opacity.value=d,i.visible=d>.01,d>.01&&(t=!0)}),this.group.visible=t}updateLOD(e){this.group.visible=!0}dispose(){this.layers.forEach(e=>{e.geometry.dispose(),e.material.dispose(),e.material.alphaMap&&e.material.alphaMap.dispose()}),this.alphaMasks=[],this.scene.remove(this.group)}}const ge={crab:{coreColor:new r(16777215),innerColor1:new r(56831),innerColor2:new r(65450),midColor1:new r(16755200),midColor2:new r(16737792),outerColor:new r(16724736),brightness:1.6,coreIntensity:2,filamentDetail:3.5},helix:{coreColor:new r(12753151),innerColor1:new r(8969727),innerColor2:new r(48127),midColor1:new r(16737962),midColor2:new r(16724872),outerColor:new r(8913151),brightness:1.4,coreIntensity:2.2,filamentDetail:2.8},orion:{coreColor:new r(16772812),innerColor1:new r(16746717),innerColor2:new r(16737979),midColor1:new r(11158783),midColor2:new r(6684927),outerColor:new r(4456618),brightness:1.5,coreIntensity:2,filamentDetail:3},emission:{coreColor:new r(16777198),innerColor1:new r(16768392),innerColor2:new r(16755285),midColor1:new r(16737843),midColor2:new r(16724753),outerColor:new r(11141120),brightness:1.7,coreIntensity:2.5,filamentDetail:3.2},reflection:{coreColor:new r(7388159),innerColor1:new r(6750207),innerColor2:new r(4521932),midColor1:new r(2293674),midColor2:new r(56712),outerColor:new r(34918),brightness:1.3,coreIntensity:1.5,filamentDetail:2.5},planetary:{coreColor:new r(16777215),innerColor1:new r(11206655),innerColor2:new r(6750122),midColor1:new r(16755302),midColor2:new r(16738047),outerColor:new r(6711039),brightness:1.6,coreIntensity:2.8,filamentDetail:3.8},purple:{coreColor:new r(16772863),innerColor1:new r(16746751),innerColor2:new r(13395711),midColor1:new r(8930559),midColor2:new r(6693580),outerColor:new r(4456618),brightness:1.4,coreIntensity:1.8,filamentDetail:2.8},blue:{coreColor:new r(12753151),innerColor1:new r(11202303),innerColor2:new r(6737151),midColor1:new r(3381759),midColor2:new r(26316),outerColor:new r(13192),brightness:1.3,coreIntensity:1.5,filamentDetail:2.6}};class we{constructor(e,n=new a(0,0,0),t={}){this.scene=e,this.position=n,this.config={blackHoleRadius:t.blackHoleRadius||t.eventHorizonRadius||15,diskInnerRadius:t.diskInnerRadius||null,diskOuterRadius:t.diskOuterRadius||t.accretionDiskRadius||80,diskTiltAngle:t.diskTiltAngle||Math.PI/3,colorHot:t.colorHot||new r(16777215),colorMid1:t.colorMid1||new r(16742195),colorMid2:t.colorMid2||new r(16729207),colorMid3:t.colorMid3||new r(7816447),colorOuter:t.colorOuter||new r(4487167),noiseScale:t.noiseScale||2.5,flowSpeed:t.flowSpeed||.22,density:t.density||1.3,brightness:t.brightness||1,fadeStartDistance:t.fadeStartDistance||300,fadeEndDistance:t.fadeEndDistance||150,...t},this.config.diskInnerRadius||(this.config.diskInnerRadius=this.config.blackHoleRadius+2),this.group=new k,this.group.position.copy(n),this.createEventHorizon(),this.createBlackHoleSphere(),this.createAccretionDisk(),this.accretionDisk&&this.accretionDisk.scale.set(0,0,0),e.add(this.group)}createEventHorizon(){const e=new x(1.05*this.config.blackHoleRadius,128,64),n=new l({uniforms:{uTime:{value:0},uCameraPosition:{value:new a},uAlpha:{value:0}},vertexShader:"\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n        \n        void main() {\n          vNormal = normalize(normalMatrix * normal);\n          vPosition = position;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        uniform float uTime;\n        uniform vec3 uCameraPosition;\n        uniform float uAlpha;\n        \n        varying vec3 vNormal;\n        varying vec3 vPosition;\n        \n        void main() {\n          if (uAlpha < 0.01) discard;\n          \n          vec3 viewDirection = normalize(uCameraPosition - vPosition);\n          float fresnel = 1.0 - abs(dot(vNormal, viewDirection));\n          fresnel = pow(fresnel, 2.5);\n          \n          vec3 glowColor = vec3(1.0, 0.4, 0.1);\n          float pulse = sin(uTime * 2.5) * 0.15 + 0.85;\n          \n          gl_FragColor = vec4(glowColor * fresnel * pulse, fresnel * 0.4 * uAlpha);\n        }\n      ",transparent:!0,blending:c,side:V,depthWrite:!1});this.eventHorizon=new u(e,n),this.group.add(this.eventHorizon)}createBlackHoleSphere(){const e=new x(this.config.blackHoleRadius,128,64),n=new B({color:0,transparent:!0,opacity:1});this.blackHoleMesh=new u(e,n),this.blackHoleMesh.renderOrder=0,this.group.add(this.blackHoleMesh)}createAccretionDisk(){const e=this.config.diskInnerRadius,n=this.config.diskOuterRadius,t=new j(e,n,256,128),o=new l({uniforms:{uTime:{value:0},uColorHot:{value:this.config.colorHot},uColorMid1:{value:this.config.colorMid1},uColorMid2:{value:this.config.colorMid2},uColorMid3:{value:this.config.colorMid3},uColorOuter:{value:this.config.colorOuter},uNoiseScale:{value:this.config.noiseScale},uFlowSpeed:{value:this.config.flowSpeed},uDensity:{value:this.config.density},uBrightness:{value:this.config.brightness},uInnerRadius:{value:e},uOuterRadius:{value:n}},vertexShader:"\n        varying vec2 vUv;\n        varying float vRadius;\n        varying float vAngle;\n        \n        void main() {\n          vUv = uv;\n          vRadius = length(position.xy);\n          vAngle = atan(position.y, position.x);\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        uniform float uTime;\n        uniform vec3 uColorHot;\n        uniform vec3 uColorMid1;\n        uniform vec3 uColorMid2;\n        uniform vec3 uColorMid3;\n        uniform vec3 uColorOuter;\n        uniform float uNoiseScale;\n        uniform float uFlowSpeed;\n        uniform float uDensity;\n        uniform float uBrightness;\n        uniform float uInnerRadius;\n        uniform float uOuterRadius;\n\n        varying vec2 vUv;\n        varying float vRadius;\n        varying float vAngle;\n\n        // Simplex noise functions\n        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n        \n        float snoise(vec3 v) {\n          const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n          const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n          \n          vec3 i = floor(v + dot(v, C.yyy));\n          vec3 x0 = v - i + dot(i, C.xxx);\n          \n          vec3 g = step(x0.yzx, x0.xyz);\n          vec3 l = 1.0 - g;\n          vec3 i1 = min(g.xyz, l.zxy);\n          vec3 i2 = max(g.xyz, l.zxy);\n          \n          vec3 x1 = x0 - i1 + C.xxx;\n          vec3 x2 = x0 - i2 + C.yyy;\n          vec3 x3 = x0 - D.yyy;\n          \n          i = mod289(i);\n          vec4 p = permute(permute(permute(\n            i.z + vec4(0.0, i1.z, i2.z, 1.0))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n            \n          float n_ = 0.142857142857;\n          vec3 ns = n_ * D.wyz - D.xzx;\n          \n          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n          vec4 x_ = floor(j * ns.z);\n          vec4 y_ = floor(j - 7.0 * x_);\n          \n          vec4 x = x_ * ns.x + ns.yyyy;\n          vec4 y = y_ * ns.x + ns.yyyy;\n          vec4 h = 1.0 - abs(x) - abs(y);\n          \n          vec4 b0 = vec4(x.xy, y.xy);\n          vec4 b1 = vec4(x.zw, y.zw);\n          \n          vec4 s0 = floor(b0) * 2.0 + 1.0;\n          vec4 s1 = floor(b1) * 2.0 + 1.0;\n          vec4 sh = -step(h, vec4(0.0));\n          \n          vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n          vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n          \n          vec3 p0 = vec3(a0.xy, h.x);\n          vec3 p1 = vec3(a0.zw, h.y);\n          vec3 p2 = vec3(a1.xy, h.z);\n          vec3 p3 = vec3(a1.zw, h.w);\n          \n          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n          p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;\n          \n          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n          m = m * m;\n          return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n        }\n\n        void main() {\n          float normalizedRadius = smoothstep(uInnerRadius, uOuterRadius, vRadius);\n          \n          // Spiral flow pattern\n          float spiral = vAngle * 3.0 - (1.0 / (normalizedRadius + 0.1)) * 2.0;\n          vec2 noiseUv = vec2(\n            vUv.x + uTime * uFlowSpeed * (2.0 / (vRadius * 0.3 + 1.0)) + sin(spiral) * 0.1,\n            vUv.y * 0.8 + cos(spiral) * 0.1\n          );\n          \n          // Multi-octave noise\n          float noiseVal1 = snoise(vec3(noiseUv * uNoiseScale, uTime * 0.15));\n          float noiseVal2 = snoise(vec3(noiseUv * uNoiseScale * 3.0 + 0.8, uTime * 0.22));\n          float noiseVal3 = snoise(vec3(noiseUv * uNoiseScale * 6.0 + 1.5, uTime * 0.3));\n          \n          float noiseVal = (noiseVal1 * 0.45 + noiseVal2 * 0.35 + noiseVal3 * 0.2);\n          noiseVal = (noiseVal + 1.0) * 0.5;\n          \n          // Color gradient (outer to inner)\n          vec3 color = uColorOuter;\n          color = mix(color, uColorMid3, smoothstep(0.0, 0.25, normalizedRadius));\n          color = mix(color, uColorMid2, smoothstep(0.2, 0.55, normalizedRadius));\n          color = mix(color, uColorMid1, smoothstep(0.5, 0.75, normalizedRadius));\n          color = mix(color, uColorHot, smoothstep(0.7, 0.95, normalizedRadius));\n          \n          // Apply noise to color\n          color *= (0.5 + noiseVal * 1.0);\n          \n          // Brightness calculation\n          float brightness = pow(1.0 - normalizedRadius, 1.0) * 3.5 + 0.5;\n          brightness *= (0.3 + noiseVal * 2.2);\n          brightness *= uBrightness;\n          \n          // Pulse animation\n          float pulse = sin(uTime * 1.8 + normalizedRadius * 12.0 + vAngle * 2.0) * 0.15 + 0.85;\n          brightness *= pulse;\n          \n          // Alpha with edge falloff\n          float alpha = uDensity * (0.2 + noiseVal * 0.9);\n          alpha *= smoothstep(0.0, 0.15, normalizedRadius);\n          alpha *= (1.0 - smoothstep(0.85, 1.0, normalizedRadius));\n          alpha = clamp(alpha, 0.0, 1.0);\n\n          gl_FragColor = vec4(color * brightness, alpha);\n        }\n      ",transparent:!0,side:E,depthWrite:!1,blending:c});this.accretionDisk=new u(t,o),this.accretionDisk.rotation.x=this.config.diskTiltAngle,this.accretionDisk.renderOrder=1,this.group.add(this.accretionDisk)}update(e,n){const t=.001*performance.now(),o=this.group.position.distanceTo(n.position),i=this.config.fadeStartDistance,a=this.config.fadeEndDistance;let r=0;o<=a?r=1:o<i&&(r=1-(o-a)/(i-a)),r=1-Math.pow(1-r,3);const s=this.group.position.clone().project(n);let l=1;if(s.z>1)l=0;else{const e=Math.sqrt(s.x*s.x+s.y*s.y);l=1-Math.min(e/1,1),l=Math.pow(l,.3)}const c=r*l;this.eventHorizon&&(this.eventHorizon.material.uniforms.uTime.value=t,this.eventHorizon.material.uniforms.uCameraPosition.value.copy(n.position),this.eventHorizon.material.uniforms.uAlpha.value=c),this.blackHoleMesh&&(this.blackHoleMesh.material.opacity=c),this.accretionDisk&&(this.accretionDisk.material.uniforms.uTime.value=t,this.accretionDisk.scale.set(c,c,c),this.accretionDisk.rotation.z+=.05*e)}getScaleFactor(e){const n=this.group.position.distanceTo(e.position),t=this.config.fadeStartDistance,o=this.config.fadeEndDistance;let i=0;n<=o?i=1:n<t&&(i=1-(n-o)/(t-o)),i=1-Math.pow(1-i,3);const a=this.group.position.clone().project(e);let r=1;if(a.z>1)r=0;else{const e=Math.sqrt(a.x*a.x+a.y*a.y);r=1-Math.min(e/1,1),r=Math.pow(r,.3)}return i*r}updateLOD(e){const n=this.group.position.distanceTo(e);this.group.visible=!(n>5e3)}dispose(){this.eventHorizon&&(this.eventHorizon.geometry.dispose(),this.eventHorizon.material.dispose()),this.blackHoleMesh&&(this.blackHoleMesh.geometry.dispose(),this.blackHoleMesh.material.dispose()),this.accretionDisk&&(this.accretionDisk.geometry.dispose(),this.accretionDisk.material.dispose()),this.scene.remove(this.group)}}const ye={standard:{blackHoleRadius:15,diskOuterRadius:80,diskTiltAngle:Math.PI/3,colorHot:new r(16777215),colorMid1:new r(16742195),colorMid2:new r(16729207),colorMid3:new r(7816447),colorOuter:new r(4487167),fadeStartDistance:300,fadeEndDistance:150},small:{blackHoleRadius:8,diskOuterRadius:40,diskTiltAngle:Math.PI/4,fadeStartDistance:200,fadeEndDistance:100},medium:{blackHoleRadius:15,diskOuterRadius:60,diskTiltAngle:Math.PI/3,fadeStartDistance:300,fadeEndDistance:150},supermassive:{blackHoleRadius:30,diskOuterRadius:150,diskTiltAngle:Math.PI/2.5,flowSpeed:.15,fadeStartDistance:500,fadeEndDistance:250},blue:{blackHoleRadius:15,diskOuterRadius:80,colorHot:new r(11206655),colorMid1:new r(4500223),colorMid2:new r(4487167),colorMid3:new r(4474111),colorOuter:new r(2237098),fadeStartDistance:300,fadeEndDistance:150},inferno:{blackHoleRadius:15,diskOuterRadius:80,colorHot:new r(16777215),colorMid1:new r(16755251),colorMid2:new r(16733440),colorMid3:new r(16720384),colorOuter:new r(8912896),fadeStartDistance:300,fadeEndDistance:150}};class be{constructor(e,n,t=1e3,o={}){this.scene=e,this.camera=n,this.chunkSize=t,this.onBlackHoleCreated=o.onBlackHoleCreated||null,this.onBlackHoleRemoved=o.onBlackHoleRemoved||null,this.objects=new Map,this.activeObjects=new Set,this.fadeDistances={fadeStart:600,fadeEnd:150,minOpacity:0},this.maxObjectsPerChunk=2,this.spawnProbability={nebula:.15,blackhole:.05},this.guaranteedBlackHole={chunkX:0,chunkY:0,chunkZ:0,position:new a(200,100,200),created:!1}}calculateDistanceOpacity(e){const{fadeStart:n,fadeEnd:t,minOpacity:o}=this.fadeDistances;if(e<=t)return 1;if(e>=n)return o;const i=(e-t)/(n-t);return o+(1-o)*(1-Math.pow(i,3))}updateNebulaLayerOpacity(e,n){}updateBlackHoleOpacity(e,n){}onChunkCreated(e,n,t){const o=`${e},${n},${t}`;if(this.objects.has(o))return void this.activateChunkObjects(o);const i=this.generateChunkObjects(e,n,t);i.length>0&&(this.objects.set(o,i),this.activateChunkObjects(o))}onChunkRemoved(e,n,t){const o=`${e},${n},${t}`;this.deactivateChunkObjects(o)}generateChunkObjects(e,n,t){const o=[],i=new a(e*this.chunkSize,n*this.chunkSize,t*this.chunkSize);if(!this.guaranteedBlackHole.created&&e===this.guaranteedBlackHole.chunkX&&n===this.guaranteedBlackHole.chunkY&&t===this.guaranteedBlackHole.chunkZ){const e=this.createBlackHoleWithNebula(this.guaranteedBlackHole.position,Math.random);e&&(o.push({type:"blackhole",object:e.blackHole}),o.push({type:"nebula",object:e.backgroundNebula,isBackground:!0}),this.guaranteedBlackHole.created=!0)}const r=this.hashChunk(e,n,t),s=this.seededRandom(r),l=Math.floor(s()*this.maxObjectsPerChunk)+1;for(let c=0;c<l;c++){const e=s(),n=new a((s()-.5)*this.chunkSize*.8,(s()-.5)*this.chunkSize*.8,(s()-.5)*this.chunkSize*.8),t=i.clone().add(n);if(e<this.spawnProbability.nebula){const e=this.createRandomNebula(t,s);e&&(e.type="nebula",o.push({type:"nebula",object:e}))}else if(e<this.spawnProbability.nebula+this.spawnProbability.blackhole){const e=this.createBlackHoleWithNebula(t,s);e&&(e.blackHole.type="blackhole",e.backgroundNebula.type="nebula",o.push({type:"blackhole",object:e.blackHole}),o.push({type:"nebula",object:e.backgroundNebula,isBackground:!0}))}}return o}createRandomNebula(e,n){const t=Object.keys(ge),o=t[Math.floor(n()*t.length)],i={...ge[o],size:400+400*n(),layers:4,brightness:.8+.8*n()};return new ve(this.scene,e,i,this.camera)}createBlackHoleWithNebula(e,n){const t=Object.keys(ye),o=t[Math.floor(n()*t.length)],i={...ye[o],brightness:1+.3*n()},a=new we(this.scene,e,i),r=3*(i.diskOuterRadius||80),s=e.clone();s.z-=r;const l={...ge.helix,size:4*(i.diskOuterRadius||80),layers:4,brightness:1.2},c=new ve(this.scene,s,l,this.camera);return a.backgroundNebula=c,a.backgroundNebulaOffset=r,this.onBlackHoleCreated&&this.onBlackHoleCreated(a.group),{blackHole:a,backgroundNebula:c}}activateChunkObjects(e){const n=this.objects.get(e);n&&n.forEach(({object:e})=>{e.group.visible=!0,this.activeObjects.add(e)})}deactivateChunkObjects(e){const n=this.objects.get(e);n&&n.forEach(({type:e,object:n})=>{this.activeObjects.delete(n),"blackhole"===e&&this.onBlackHoleRemoved&&this.onBlackHoleRemoved(n.group)})}update(e){this.objects.forEach(n=>{n.forEach(({type:n,object:t})=>{if(!t.group.visible)return;const o=t.group.position.distanceTo(this.camera.position);"nebula"===n?(t.update(e,this.camera),t.updateLOD(this.camera.position),this.updateNebulaLayerOpacity(t,o)):"blackhole"===n?(t.update(e,this.camera),t.updateLOD(this.camera.position)):(t.update&&t.update(e,this.camera),t.updateLOD&&t.updateLOD(this.camera.position))})}),this.objects.forEach(e=>{e.forEach(({object:e})=>{if(e.group.visible&&e.backgroundNebula&&e.backgroundNebulaOffset){const n=new a;n.subVectors(e.group.position,this.camera.position).normalize();const t=e.group.position.clone();t.add(n.multiplyScalar(e.backgroundNebulaOffset)),e.backgroundNebula.group.position.copy(t)}})})}hashChunk(e,n,t){let o=0;const i=`${e},${n},${t}`;for(let a=0;a<i.length;a++){o=(o<<5)-o+i.charCodeAt(a),o&=o}return Math.abs(o)}seededRandom(e){let n=e;return function(){return n=(9301*n+49297)%233280,n/233280}}dispose(){this.objects.forEach(e=>{e.forEach(({object:e})=>{e.dispose&&e.dispose()})}),this.objects.clear(),this.activeObjects.clear()}}function xe(e){return Math.max(0,Math.min(1,e))}function Me(e,n,t){const o=xe((t-e)/(n-e));return o*o*(3-2*o)}function Ce(e){return Me(0,1,e)}function ke(e){const n=document.createElement("div");n.className=`audio-proximity-icon audio-proximity-icon--${e}`,n.style.position="fixed",n.style.top="50%",n.style.width="42px",n.style.height="300px",n.style.opacity="0",n.style.willChange="opacity, transform, left, right","right"===e?(n.style.right="18px",n.style.transform="translateY(-50%) scaleX(-1)"):(n.style.left="18px",n.style.transform="translateY(-50%)");const t=document.createElementNS("http://www.w3.org/2000/svg","svg");t.setAttribute("viewBox","0 0 137.16 982.26"),t.setAttribute("width","42"),t.setAttribute("height","300");const o=document.createElementNS("http://www.w3.org/2000/svg","defs"),i=document.createElementNS("http://www.w3.org/2000/svg","clipPath");i.setAttribute("id",`clipTop-${e}`);const a=document.createElementNS("http://www.w3.org/2000/svg","rect");a.setAttribute("x","0"),a.setAttribute("y","982.26"),a.setAttribute("width","137.16"),a.setAttribute("height","0"),i.appendChild(a);const r=document.createElementNS("http://www.w3.org/2000/svg","clipPath");r.setAttribute("id",`clipBottom-${e}`);const s=document.createElementNS("http://www.w3.org/2000/svg","rect");s.setAttribute("x","0"),s.setAttribute("y","0"),s.setAttribute("width","137.16"),s.setAttribute("height","0"),r.appendChild(s),o.appendChild(i),o.appendChild(r),t.appendChild(o);const l=document.createElementNS("http://www.w3.org/2000/svg","path");l.setAttribute("d","M137.16,982.26c-47.27-95.88-80.26-239.71-88.92-404.49h-6.19c9.24,166.02,44.64,310.35,95.12,404.49Z"),l.setAttribute("fill","#ffffff"),l.setAttribute("clip-path",`url(#clipTop-${e})`);const c=document.createElementNS("http://www.w3.org/2000/svg","path");c.setAttribute("d","M48.25,404.22C56.93,239.55,89.91,95.83,137.16,0,86.7,94.09,51.32,238.31,42.06,404.22h6.19Z"),c.setAttribute("fill","#ffffff"),c.setAttribute("clip-path",`url(#clipBottom-${e})`);const d=30,u=[{x:0,y:476,w:10,h:d,rx:5,ry:5},{x:19.58,y:476,w:10,h:d,rx:5,ry:5},{x:40.15,y:476,w:10,h:d,rx:5,ry:5},{x:58.73,y:476,w:10,h:d,rx:5,ry:5},{x:78.31,y:476,w:10,h:d,rx:5,ry:5}].map(e=>{const n=document.createElementNS("http://www.w3.org/2000/svg","rect");return n.setAttribute("x",String(e.x)),n.setAttribute("y",String(e.y)),n.setAttribute("width",String(e.w)),n.setAttribute("height",String(e.h)),n.setAttribute("rx",String(e.rx)),n.setAttribute("ry",String(e.ry)),n.setAttribute("fill","#ffffff"),n.style.transformBox="fill-box",n.style.transformOrigin="50% 50%",n.style.willChange="transform",n.style.vectorEffect="non-scaling-stroke",n});return t.appendChild(l),t.appendChild(c),u.forEach(e=>t.appendChild(e)),n.appendChild(t),{wrapper:n,svg:t,clipTopRect:a,clipBottomRect:s,barEls:u}}const De={uniforms:{tDiffuse:{value:null},blackHoleScreenPos:{value:new d(.5,.5)},lensingStrength:{value:.12},lensingRadius:{value:.3},aspectRatio:{value:1},chromaticAberration:{value:.005}},vertexShader:"\n    varying vec2 vUv;\n    \n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform vec2 blackHoleScreenPos;\n    uniform float lensingStrength;\n    uniform float lensingRadius;\n    uniform float aspectRatio;\n    uniform float chromaticAberration;\n    \n    varying vec2 vUv;\n    \n    void main() {\n      vec2 screenPos = vUv;\n      vec2 toCenter = screenPos - blackHoleScreenPos;\n      toCenter.x *= aspectRatio;\n      float dist = length(toCenter);\n      \n      // ‚≠ê Radius 0 ise efekt yok\n      if (lensingRadius < 0.001) {\n        gl_FragColor = texture2D(tDiffuse, vUv);\n        return;\n      }\n      \n      // Gravitational distortion - 1/r¬≤ falloff\n      float distortionAmount = lensingStrength / (dist * dist + 0.003);\n      distortionAmount = clamp(distortionAmount, 0.0, 0.7);\n      \n      // Smooth falloff at edges\n      float falloff = smoothstep(lensingRadius, lensingRadius * 0.3, dist);\n      distortionAmount *= falloff;\n      \n      // Calculate offset\n      vec2 offset = normalize(toCenter) * distortionAmount;\n      offset.x /= aspectRatio;\n      \n      // Chromatic aberration - R/G/B slightly different offsets\n      vec2 distortedUvR = screenPos - offset * (1.0 + chromaticAberration);\n      vec2 distortedUvG = screenPos - offset;\n      vec2 distortedUvB = screenPos - offset * (1.0 - chromaticAberration);\n      \n      // Sample each color channel separately\n      float r = texture2D(tDiffuse, distortedUvR).r;\n      float g = texture2D(tDiffuse, distortedUvG).g;\n      float b = texture2D(tDiffuse, distortedUvB).b;\n      \n      gl_FragColor = vec4(r, g, b, 1.0);\n    }\n  "};if(window.THREE=K,window.__audioContexts=window.__audioContexts||[],window.AudioContext){const e=window.AudioContext;window.AudioContext=function(...n){const t=new e(...n);return window.__audioContexts.push(t),t}}window.SunCalc=ie;const Se=new ae;Se.showPanel(0),Se.dom.style.position="fixed",Se.dom.style.left="10px",Se.dom.style.top="10px",document.body.appendChild(Se.dom);const Pe=document.querySelector("canvas.webgl"),ze=new X;Z.enabled=!1,window.scene=ze;const Ae=new Q({canvas:Pe,antialias:!0,powerPreference:"high-performance"});Ae.outputColorSpace=J,Ae.setSize(window.innerWidth,window.innerHeight),Ae.setPixelRatio(Math.min(window.devicePixelRatio,2)),Ae.shadowMap.enabled=!0,Ae.shadowMap.type=ee;const{camera:Te,controls:Re,idleSystem:He}=function(e,n){const t=new w(45,window.innerWidth/window.innerHeight,.1,1e5);t.position.set(0,0,10),e.add(t),window.camera=t;const o=new y;t.add(o),t.userData.audioListener=o;const i=new re(t,n.domElement);i.enableDamping=!0,i.dampingFactor=.05,i.enablePan=!0,i.enableZoom=!0,i.minDistance=0,i.maxDistance=1/0,i.zoomSpeed=20,i.panSpeed=20,n.setAnimationLoop(()=>{const e=new a;t.getWorldDirection(e),i.target.copy(t.position).add(e)});let r=null;window.addEventListener("dblclick",e=>{const n=new d(e.clientX/window.innerWidth*2-1,-e.clientY/window.innerHeight*2+1),o=new b;o.setFromCamera(n,t);const s=o.ray.direction.clone();!function(e,n=1e3){const o=t.position.clone(),s=i.target.clone(),l=new a;t.getWorldDirection(l);const c=e.clone().add(l),d=performance.now();r&&cancelAnimationFrame(r),r=requestAnimationFrame(function a(l){const u=Math.min((l-d)/n,1),h=1-Math.pow(1-u,3);t.position.lerpVectors(o,e,h),i.target.lerpVectors(s,c,h),r=u<1?requestAnimationFrame(a):null})}(t.position.clone().add(s.multiplyScalar(300)))}),window.controls=i;const s=function(e,n,t={}){const o=t.timeout||15e3;t.transitionDuration,t.rotationSpeed;let i=Date.now(),r=!1;const s={yaw:0,pitch:0,targetYaw:0,targetPitch:0,changeTimer:0,savedTarget:null};function l(){i=Date.now(),r=!1}function c(t){const l=Date.now();if(!r&&l-i>o&&(r=!0,s.savedTarget=n.target.clone(),s.yaw=0,s.pitch=0,s.targetYaw=0,s.targetPitch=0,s.changeTimer=3+2*Math.random()),!r)return;s.changeTimer-=t,s.changeTimer<=0&&(s.targetYaw=.15*(Math.random()-.5),s.targetPitch=.08*(Math.random()-.5),s.changeTimer=8+7*Math.random());const c=.5*t;s.yaw+=(s.targetYaw-s.yaw)*c,s.pitch+=(s.targetPitch-s.pitch)*c;const d=.16*t,u=(new a).subVectors(e.position,n.target),h=u.length();let m=Math.atan2(u.x,u.z),p=Math.acos(Math.max(-1,Math.min(1,u.y/h)));m+=s.yaw*d,p+=s.pitch*d,p=Math.max(.1,Math.min(Math.PI-.1,p)),u.x=h*Math.sin(p)*Math.sin(m),u.y=h*Math.cos(p),u.z=h*Math.sin(p)*Math.cos(m),e.position.copy(n.target).add(u),s.savedTarget&&n.target.copy(s.savedTarget)}function d(){return r}function u(e){void 0!==e.timeout&&(o=e.timeout),void 0!==e.rotationSpeed&&e.rotationSpeed}const h=["mousemove","mousedown","wheel","keydown","touchstart","touchmove"];return h.forEach(e=>{window.addEventListener(e,l)}),{update:c,reset:l,get isIdle(){return d()},updateConfig:u,dispose:()=>{h.forEach(e=>{window.removeEventListener(e,l)})}}}(t,i);return{camera:t,controls:i,idleSystem:s}}(ze,Ae);window.camera=Te,Te.position.set(400,400,400),Re.target.set(0,0,0),Te.lookAt(0,0,0),Re.update();const Ee=new le(Ae),Le=new ce(ze,Te);Ee.addPass(Le);const Fe=new de(new d(window.innerWidth,window.innerHeight),.7,.4,.85);Ee.addPass(Fe);const Ne=new class{constructor(e,n){this.camera=n,this.pass=new se(De),this.blackHoles=[],this.screenPosVec3=new a,this.fadeStartDistance=300,this.fadeEndDistance=150,this.maxStrength=.12,this.maxRadius=.3,e.addPass(this.pass),this.updateAspectRatio()}addBlackHole(e){this.blackHoles.push(e)}removeBlackHole(e){const n=this.blackHoles.indexOf(e);n>-1&&this.blackHoles.splice(n,1)}updateAspectRatio(){this.pass.uniforms.aspectRatio.value=window.innerWidth/window.innerHeight}update(){if(0===this.blackHoles.length)return this.pass.uniforms.lensingStrength.value=0,void(this.pass.uniforms.lensingRadius.value=0);let e=null,n=1/0;for(const d of this.blackHoles){if(!d.visible)continue;const t=this.camera.position.distanceTo(d.position);t<n&&(n=t,e=d)}if(!e)return this.pass.uniforms.lensingStrength.value=0,void(this.pass.uniforms.lensingRadius.value=0);if(this.screenPosVec3.copy(e.position).project(this.camera),this.screenPosVec3.z>1)return this.pass.uniforms.lensingStrength.value=0,void(this.pass.uniforms.lensingRadius.value=0);const t=(this.screenPosVec3.x+1)/2,o=(this.screenPosVec3.y+1)/2;this.pass.uniforms.blackHoleScreenPos.value.set(t,o);const i=this.fadeStartDistance,a=this.fadeEndDistance;let r=0;n<=a?r=1:n<i&&(r=1-(n-a)/(i-a)),r=1-Math.pow(1-r,3);const s=Math.sqrt(this.screenPosVec3.x*this.screenPosVec3.x+this.screenPosVec3.y*this.screenPosVec3.y);let l=1-Math.min(s/1,1);l=Math.pow(l,.3);const c=r*l;this.pass.uniforms.lensingStrength.value=this.maxStrength*c,this.pass.uniforms.lensingRadius.value=this.maxRadius*c}setStrength(e){this.maxStrength=e}setRadius(e){this.maxRadius=e}setChromaticAberration(e){this.pass.uniforms.chromaticAberration.value=e}setFadeDistances(e,n){this.fadeStartDistance=e,this.fadeEndDistance=n}dispose(){this.blackHoles=[]}}(Ee,Te);window.gravitationalLensing=Ne;const{helpers:Oe,gridHelper:Ie,axesHelper:Ue}=function(e){const n={grid:!0,axes:!0,sunHelperVisible:!0,moonHelperVisible:!0},t=new p(100,100);t.visible=n.grid,t.userData.noOcclusion=!0,t.material.color.set(16777215),t.material.opacity=.5,t.material.transparent=!0,e.add(t);const o=new f(50);return o.setColors(new r(16729156),new r(4521796),new r(4491519)),o.visible=n.axes,o.userData.noOcclusion=!0,e.add(o),{helpers:n,gridHelper:t,axesHelper:o}}(ze),{sunLight:Ve,moonLight:Be,sunHelper:je,moonHelper:_e}=function(e){const n=new v(16774374,1.2),t=new v(10403327,.4);t.color.set(10403327),n.visible=!1,t.visible=!1,e.add(n,t);const o=new g(n,5,16768256),i=new g(t,5,6728447);return o.userData.noOcclusion=!0,i.userData.noOcclusion=!0,e.add(o),e.add(i),{sunLight:n,moonLight:t,sunHelper:o,moonHelper:i}}(ze);Ie&&(Ie.visible=!1),Ue&&(Ue.visible=!1);const We=[];Ie&&We.push(Ie),Ue&&We.push(Ue),Oe&&(Array.isArray(Oe)?We.push(...Oe):We.push(Oe)),We.forEach(e=>{e&&(e.isObject3D&&e.traverse?e.traverse(e=>{e.userData=e.userData||{},e.userData.ignoreScan=!0}):(e.userData=e.userData||{},e.userData.ignoreScan=!0))});const Ge=new class{constructor(e,n){this.scene=e,this.camera=n,this.chunkSize=1e3,this.renderDistance=1,this.unloadDistance=2,this.chunks=new Map,this.chunkPool=[],this.audioLoader=new _,this.audioListener=n.userData.audioListener,this.textureLoader=new M,this.audioPlanetPositions=this._generateRandomAudioPlanetPositions(),this.placedAudioPlanets=new Set,this.audioPlanetConfigs=[{id:1,name:"Tletl",element:"fire",audioFile:"/sounds/fire_tletl.mp3",radius:10,volume:.5,texture:"./textures/signal.jpg",description:"üî• Ate≈ü - Kutsal Alev, D√∂n√º≈ü√ºm Enerjisi"},{id:2,name:"ƒÄtl",element:"water",audioFile:"/sounds/water_atl.mp3.mp3",radius:12,volume:.6,texture:"./textures/signal.jpg",description:"üíß Su - Ya≈üamƒ±n √ñz√º, Arƒ±nma"},{id:3,name:"Tlalli",element:"earth",audioFile:"/sounds/earth_tlalli.mp3",radius:8,volume:.4,texture:"./textures/signal.jpg",description:"üåç Toprak - Yery√ºz√º, Maddesel D√ºnya"},{id:4,name:"Ehecatl",element:"wind",audioFile:"/sounds/wind_ehecatl.mp3",radius:15,volume:.7,texture:"./textures/signal.jpg",description:"üå¨Ô∏è Hava - R√ºzgar Tanrƒ±sƒ±, Nefes"},{id:5,name:"Tonatiuh",element:"sun",audioFile:"/sounds/sun_tonatiuh.mp3.mp3",radius:11,volume:.55,texture:"./textures/signal.jpg",description:"‚òÄÔ∏è G√ºne≈ü - Be≈üinci √áaƒüƒ±n G√ºne≈üi"}],this.cosmicManager=new be(e,n,this.chunkSize)}_generateRandomAudioPlanetPositions(){const e=[],n={x:0,y:0,z:0};e.push(n);for(let t=1;t<5;t++){let n,t=0;do{n={x:0+Math.floor(3*Math.random()-1),y:0+Math.floor(3*Math.random()-1),z:0+Math.floor(3*Math.random()-1)};if(!e.some(e=>{const t=n.x-e.x,o=n.y-e.y,i=n.z-e.z;return Math.sqrt(t*t+o*o+i*i)<2}))break;t++}while(t<100);e.push(n)}return e}update(e=.016){const n=Math.floor(this.camera.position.x/this.chunkSize),t=Math.floor(this.camera.position.y/this.chunkSize),o=Math.floor(this.camera.position.z/this.chunkSize);for(let i=-this.renderDistance;i<=this.renderDistance;i++)for(let e=-this.renderDistance;e<=this.renderDistance;e++)for(let a=-this.renderDistance;a<=this.renderDistance;a++){const r=this._getChunkKey(n+i,t+e,o+a);this.chunks.has(r)||this._createChunk(n+i,t+e,o+a)}for(const i of this.chunks.keys()){const[e,a,r]=i.split(",").map(Number),s=Math.abs(e-n),l=Math.abs(a-t),c=Math.abs(r-o);(s>this.unloadDistance||l>this.unloadDistance||c>this.unloadDistance)&&this._removeChunk(i)}for(const[i,a]of this.chunks)a.update(1e-4,e);this.cosmicManager.update(e)}_getChunkKey(e,n,t){return`${e},${n},${t}`}_createChunk(e,n,t){const o=this._getChunkKey(e,n,t),i=new a(e*this.chunkSize,n*this.chunkSize,t*this.chunkSize),r=this.chunkPool.pop()||new fe;r.group.position.copy(i);for(let a=0;a<this.audioPlanetPositions.length;a++){const o=this.audioPlanetPositions[a],i=`${o.x},${o.y},${o.z}`;if(o.x===e&&o.y===n&&o.z===t&&!this.placedAudioPlanets.has(i)){const e=this.audioPlanetConfigs[a];this._addAudioReference(r.group,e),this.placedAudioPlanets.add(i)}}this.scene.add(r.group),this.chunks.set(o,r),this.cosmicManager.onChunkCreated(e,n,t)}_addAudioReference(e,n){const t=function({chunkSize:e,audioListener:n,audioLoader:t,audioFile:o="/sounds/space_howling.mp3",radius:i=10,planetId:a=0,volume:r=.5,loop:s=!0}={}){const d=new k,h={planetId:{value:a},odinFactor:{value:0},revealAlpha:{value:0},time:{value:0},glowIntensity:{value:1},flowSpeed:{value:.05},distortionAmount:{value:.15}},p=new l({uniforms:h,vertexShader:"\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vViewPosition;\n    varying vec3 vWorldPosition;\n\n    void main() {\n      vUv = uv;\n      vNormal = normalize(normalMatrix * normal);\n\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPosition.xyz;\n\n      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n      vViewPosition = -mvPosition.xyz;\n\n      gl_Position = projectionMatrix * mvPosition;\n    }\n  ",fragmentShader:"\n    uniform int planetId;\n    uniform float odinFactor;\n    uniform float revealAlpha;\n    uniform float time;\n    uniform float glowIntensity;\n    uniform float flowSpeed;\n    uniform float distortionAmount;\n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vViewPosition;\n    varying vec3 vWorldPosition;\n\n    vec2 rotate2D(vec2 uv, float th) {\n      return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n    }\n\n    // Procedural Neural Noise (mask)\n    float neuro_shape(vec2 uv, float t, float p) {\n      vec2 sine_acc = vec2(0.0);\n      vec2 res = vec2(0.0);\n      float scale = 8.0;\n\n      for (int j = 0; j < 15; j++) {\n        uv = rotate2D(uv, 1.0);\n        sine_acc = rotate2D(sine_acc, 1.0);\n        vec2 layer = uv * scale + float(j) + sine_acc - t;\n        sine_acc += sin(layer) + 2.4 * p;\n        res += (0.5 + 0.5 * cos(layer)) / scale;\n        scale *= 1.2;\n      }\n      return res.x + res.y;\n    }\n\n    void main() {\n\n      if (odinFactor < 0.01) discard;\n\n      // UV flow (original behavior preserved)\n      vec2 flowUv = vUv;\n      float timeFlow = time * flowSpeed;\n\n      float angle = timeFlow * 0.3;\n      vec2 center = vec2(0.5);\n      vec2 toCenter = flowUv - center;\n      float dist = length(toCenter);\n\n      vec2 flow = vec2(\n        cos(dist * 3.0 + angle),\n        sin(dist * 3.0 + angle)\n      ) * distortionAmount;\n\n      float wave = sin(flowUv.y * 10.0 + timeFlow * 2.0) * 0.02;\n      flowUv.x += wave;\n      flowUv += flow;\n\n      // Neural noise mask\n      vec2 uv = 0.5 * flowUv;\n      float p = 0.18;\n      float t = 0.001 * (time * 1000.0);\n\n      float n = neuro_shape(uv, t, p);\n      n = 1.2 * pow(n, 3.0);\n      n += pow(n, 10.0);\n      n = max(0.0, n - 0.5);\n      n *= (1.0 - length(flowUv - 0.5));\n\n      float signalSample = clamp(1.0 - n, 0.0, 1.0);\n\n      float glowMask  = pow(1.0 - signalSample, 0.9);\n      float alphaMask = 1.0 - signalSample;\n\n      vec3 viewDir = normalize(vViewPosition);\n      float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 3.0);\n\n      // X-RAY PHASE\n      float xrayIntensity = pow(1.0 - odinFactor, 1.5);\n      float scanPulse = sin(time * 2.0 + vWorldPosition.y * 0.05) * 0.5 + 0.5;\n      xrayIntensity *= (0.8 + scanPulse * 0.2);\n\n      vec3 xrayGlow = vec3(0.0, 0.4, 1.0) * xrayIntensity * fresnel * 1.2;\n\n      // Element colors\n      float colorShift = sin(time * 0.3) * 0.1 + 0.9;\n      vec3 centerColor;\n      vec3 edgeColor;\n\n      if (planetId == 1) {\n        centerColor = vec3(1.0, 0.5, 0.1) * colorShift;\n        edgeColor   = vec3(1.0, 0.0, 0.0);\n      } else if (planetId == 2) {\n        centerColor = vec3(0.3, 0.9, 1.0) * colorShift;\n        edgeColor   = vec3(0.0, 0.5, 0.8);\n      } else if (planetId == 3) {\n        centerColor = vec3(0.8, 0.5, 0.2) * colorShift;\n        edgeColor   = vec3(0.4, 0.25, 0.1);\n      } else if (planetId == 4) {\n        centerColor = vec3(1.0) * colorShift;\n        edgeColor   = vec3(0.7, 0.8, 0.9);\n      } else if (planetId == 5) {\n        centerColor = vec3(1.0, 0.9, 0.3) * colorShift;\n        edgeColor   = vec3(1.0, 0.6, 0.0);\n      } else {\n        centerColor = vec3(0.5) * colorShift;\n        edgeColor   = vec3(0.3);\n      }\n\n      vec3 gradientColor = mix(centerColor, edgeColor, fresnel);\n\n      vec3 baseColor = gradientColor * 0.75;\n      vec3 rimColor  = gradientColor * fresnel * 0.25;\n      vec3 materialColor = baseColor + glowMask * glowIntensity * baseColor + rimColor;\n\n      vec3 finalColor = mix(xrayGlow, materialColor, odinFactor);\n      finalColor = clamp(finalColor, 0.0, 1.0);\n\n      float finalAlpha = alphaMask * revealAlpha;\n      finalAlpha *= 1.25;\n      finalAlpha += xrayIntensity * 0.25;\n      finalAlpha = clamp(finalAlpha, 0.0, 1.0);\n\n      gl_FragColor = vec4(finalColor, finalAlpha);\n    }\n  ",transparent:!0,depthWrite:!1,side:E,blending:c}),f=new u(new x(i,32,32),p);f.position.set(m.randFloatSpread(e),m.randFloatSpread(e),m.randFloatSpread(e)),f.userData.odinUniform=h.odinFactor,f.userData.revealUniform=h.revealAlpha,f.userData.discovered=!1,f.userData.isAudioPlanet=!0,f.visible=!1;let v=1,g=1,w=0,y=.05,b=.05,M=0;f.onBeforeRender=()=>{h.time.value=performance.now()/1e3,f.rotation.y+=.0015;const e=performance.now();e-w>500&&(g=m.randFloat(1,1.4),w=e),v=m.lerp(v,g,.02),h.glowIntensity.value=v,e-M>3e3&&(b=m.randFloat(.03,.08),M=e),y=m.lerp(y,b,.01),h.flowSpeed.value=y};const C=new L(n);return t.load(o,e=>{C.setBuffer(e),C.setRefDistance(20),C.setRolloffFactor(2),C.setDistanceModel("exponential"),C.setMaxDistance(500),C.setLoop(s),C.setVolume(r),C.play()},void 0,()=>{}),C.position.copy(f.position),d.add(f),d.add(C),d}({chunkSize:this.chunkSize,audioListener:this.audioListener,audioLoader:this.audioLoader,audioFile:n.audioFile,radius:n.radius,planetId:n.id,volume:n.volume,loop:!0,textureLoader:this.textureLoader});t&&(t.traverse(e=>{e.isMesh&&e.userData.isAudioPlanet&&(e.userData.audioPlanetId=n.id)}),e.add(t))}_removeChunk(e){const n=this.chunks.get(e);n&&(this.scene.remove(n.group),this.chunkPool.push(n),this.chunks.delete(e));const[t,o,i]=e.split(",").map(Number);this.cosmicManager.onChunkRemoved(t,o,i)}dispose(){for(const[e,n]of this.chunks)this.scene.remove(n.group);this.chunks.clear(),this.chunkPool=[],this.cosmicManager.dispose()}}(ze,Te);window.chunkManager=Ge,Ge.cosmicManager.onBlackHoleCreated=e=>{Ne.addBlackHole(e)},Ge.cosmicManager.onBlackHoleRemoved=e=>{Ne.removeBlackHole(e)};const qe=new class{constructor(e,n){this.scene=e,this.camera=n,this.raycaster=new b,this.mouse=new d,this.hoveredPlanet=null,this.spectrogramCanvas=null,this.spectrogramCtx=null,this.analyser=null,this.dataArray=null,this.visible=!1,this.spectrogramHistory=[],this.maxHistoryLength=512,this.minFreq=20,this.maxFreq=2e4,this.freqBins=256,this.hiddenMessages=new Map,this.setupEventListeners()}setupEventListeners(){window.addEventListener("mousemove",e=>this.onMouseMove(e))}onMouseMove(e){this.mouse.x=e.clientX/window.innerWidth*2-1,this.mouse.y=-e.clientY/window.innerHeight*2+1,this.raycaster.setFromCamera(this.mouse,this.camera);const n=[];this.scene.traverse(e=>{e.isMesh&&e.userData.isAudioPlanet&&e.userData.discovered&&n.push(e)});const t=this.raycaster.intersectObjects(n);if(t.length>0){const e=t[0].object;this.hoveredPlanet!==e&&(this.hoveredPlanet=e,this.createSpectrogram(e))}else this.hoveredPlanet&&(this.hoveredPlanet=null,this.hideSpectrogram())}setHiddenMessage(e,n){this.hiddenMessages.set(e,n)}createSpectrogram(e){var n;if(!this.spectrogramCanvas){const t=document.createElement("canvas");t.width=this.maxHistoryLength,t.height=this.freqBins;const o=document.createElement("div");o.id="spectrogram-container",o.style.cssText="\n        position: fixed;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        height: 340px;\n        background: linear-gradient(180deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 15, 25, 0.98) 100%);\n        backdrop-filter: blur(20px);\n        border-top: 1px solid rgba(100, 150, 255, 0.3);\n        box-shadow: 0 -8px 40px rgba(0, 0, 0, 0.8), 0 -2px 20px rgba(0, 100, 255, 0.2);\n        z-index: 9998;\n        opacity: 0;\n        transition: opacity 0.4s ease;\n        display: flex;\n        flex-direction: column;\n        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;\n      ";const i=document.createElement("div");i.style.cssText="\n        height: 50px;\n        padding: 0 24px;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        background: linear-gradient(90deg, rgba(0, 100, 255, 0.1) 0%, transparent 100%);\n        border-bottom: 1px solid rgba(100, 150, 255, 0.2);\n      ";const a=document.createElement("div"),r=["","TLETL (Fire)","ƒÄTL (Water)","TLALLI (Earth)","EHECATL (Wind)","TONATIUH (Sun)"],s=(null==(n=e.userData)?void 0:n.audioPlanetId)||0;a.innerHTML=`\n        <div style="display: flex; align-items: center; gap: 12px;">\n          <div style="width: 8px; height: 8px; border-radius: 50%; background: #00ff88; box-shadow: 0 0 12px #00ff88; animation: pulse 2s ease-in-out infinite;"></div>\n          <span style="color: rgba(255, 255, 255, 0.9); font-size: 14px; font-weight: 600; letter-spacing: 1px;">${r[s]||"AUDIO PLANET"}</span>\n        </div>\n      `;const l=document.createElement("div");l.style.cssText="\n        display: flex;\n        gap: 24px;\n        color: rgba(255, 255, 255, 0.5);\n        font-size: 11px;\n        letter-spacing: 0.5px;\n      ",l.innerHTML='\n        <span>FFT: <strong style="color: rgba(255, 255, 255, 0.8);">8192</strong></span>\n        <span>RANGE: <strong style="color: rgba(255, 255, 255, 0.8);">20Hz - 20kHz</strong></span>\n        <span>MODE: <strong style="color: #00ff88;">SPECTRAL ANALYSIS</strong></span>\n      ',i.appendChild(a),i.appendChild(l);const c=document.createElement("div");c.style.cssText="\n        flex: 1;\n        position: relative;\n        display: flex;\n        padding: 12px;\n        gap: 8px;\n      ";const d=document.createElement("div");d.id="y-axis-labels",d.style.cssText="\n        width: 60px;\n        display: flex;\n        flex-direction: column;\n        justify-content: space-between;\n        padding: 8px 0;\n        color: rgba(255, 255, 255, 0.4);\n        font-size: 10px;\n        text-align: right;\n        padding-right: 8px;\n      ";["20kHz","15kHz","10kHz","5kHz","2kHz","1kHz","500Hz","100Hz","20Hz"].forEach(e=>{const n=document.createElement("span");n.textContent=e,n.style.cssText="line-height: 1; font-weight: 500;",d.appendChild(n)});const u=document.createElement("div");u.style.cssText="\n        flex: 1;\n        position: relative;\n        border: 1px solid rgba(100, 150, 255, 0.2);\n        border-radius: 4px;\n        overflow: hidden;\n        background: #000000;\n        box-shadow: inset 0 0 20px rgba(0, 100, 255, 0.1);\n      ",t.style.cssText="\n        width: 100%;\n        height: 100%;\n        image-rendering: pixelated;\n        display: block;\n      ",u.appendChild(t),c.appendChild(d),c.appendChild(u);const h=document.createElement("div");h.style.cssText="\n        height: 30px;\n        padding: 0 72px 0 72px;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        background: rgba(0, 0, 0, 0.5);\n        border-top: 1px solid rgba(100, 150, 255, 0.15);\n        color: rgba(255, 255, 255, 0.4);\n        font-size: 10px;\n      ",h.innerHTML='\n        <span>‚Üê PAST</span>\n        <span style="color: rgba(255, 255, 255, 0.6);">TIME AXIS</span>\n        <span>NOW ‚Üí</span>\n      ',o.appendChild(i),o.appendChild(c),o.appendChild(h),document.body.appendChild(o);const m=document.createElement("style");m.textContent="\n        @keyframes pulse {\n          0%, 100% { opacity: 1; transform: scale(1); }\n          50% { opacity: 0.6; transform: scale(0.8); }\n        }\n      ",document.head.appendChild(m),this.spectrogramCanvas=t,this.spectrogramCtx=t.getContext("2d",{willReadFrequently:!0,alpha:!1}),this.spectrogramHistory=[],setTimeout(()=>{o.style.opacity="1"},10)}const t=this.findAudioSource(e);t&&(this.setupAnalyser(t),this.visible=!0)}findAudioSource(e){let n=null;return e.parent&&e.parent.traverse(e=>{"Audio"!==e.type&&"PositionalAudio"!==e.type||(n=e)}),n}setupAnalyser(e){if(!e)return;const n=e.context;if(!this.analyser){this.analyser=n.createAnalyser(),this.analyser.fftSize=8192,this.analyser.smoothingTimeConstant=.3;try{e.getOutput().connect(this.analyser)}catch(t){return}const o=this.analyser.frequencyBinCount;this.dataArray=new Uint8Array(o)}}hideSpectrogram(){const e=document.getElementById("spectrogram-container");e&&(e.style.opacity="0",setTimeout(()=>{!this.hoveredPlanet&&e.parentNode&&(e.remove(),this.spectrogramCanvas=null,this.spectrogramCtx=null,this.spectrogramHistory=[])},400)),this.analyser=null,this.dataArray=null,this.visible=!1}drawStaticUI(){const e=this.spectrogramCtx,n=this.spectrogramCanvas.width;this.spectrogramCanvas.height,e.strokeStyle="rgba(100, 150, 255, 0.08)",e.lineWidth=1;[100,500,1e3,2e3,5e3,1e4,15e3,2e4].forEach(t=>{const o=this.freqToY(t);e.beginPath(),e.moveTo(0,o),e.lineTo(n,o),e.stroke()})}freqToY(e){const n=this.spectrogramCanvas.height,t=Math.log10(this.minFreq),o=Math.log10(this.maxFreq);return n-(Math.log10(e)-t)/(o-t)*n}binToFreq(e,n){return e*n/this.analyser.fftSize}getSpectrogramColor(e){const n=e/255;if(n<.2){const e=n/.2;return{r:0,g:0,b:Math.floor(128*e)}}if(n<.4){const e=(n-.2)/.2;return{r:0,g:Math.floor(255*e),b:128+Math.floor(127*e)}}if(n<.6){const e=(n-.4)/.2;return{r:0,g:255,b:Math.floor(255*(1-e))}}if(n<.8){const e=(n-.6)/.2;return{r:Math.floor(255*e),g:255,b:0}}{const e=(n-.8)/.2;return{r:255,g:Math.floor(255*(1-.5*e)),b:Math.floor(255*e)}}}embedHiddenMessage(e,n){const t=this.hiddenMessages.get(n);if(!t)return;const o=this.spectrogramCtx,i=this.spectrogramCanvas.width,a=this.spectrogramCanvas.height,r=Math.floor(.25*a),s=Math.floor(.35*i);o.save(),o.fillStyle="rgba(0, 255, 136, 0.15)",o.fillRect(s-10,r-20,200,30),o.strokeStyle="rgba(0, 255, 136, 0.5)",o.lineWidth=1,o.strokeRect(s-10,r-20,200,30),o.font="bold 14px Consolas, monospace",o.fillStyle="#00ff88",o.shadowColor="#00ff88",o.shadowBlur=8,o.fillText(`‚Üí ${t}`,s,r),o.shadowBlur=16,o.fillText(`‚Üí ${t}`,s,r),o.restore()}update(){var e;if(!(this.visible&&this.hoveredPlanet&&this.analyser&&this.spectrogramCtx))return;const n=this.spectrogramCtx,t=this.spectrogramCanvas,o=t.width,i=t.height;this.analyser.getByteFrequencyData(this.dataArray);const a=n.getImageData(1,0,o-1,i);n.putImageData(a,0,0);const r=this.analyser.context.sampleRate;for(let l=0;l<i;l++){const e=this.yToFreq(l),t=Math.floor(e*this.analyser.fftSize/r);if(t>=0&&t<this.dataArray.length){const e=this.dataArray[t],i=this.getSpectrogramColor(e);n.fillStyle=`rgb(${i.r}, ${i.g}, ${i.b})`,n.fillRect(o-1,l,1,1)}}const s=null==(e=this.hoveredPlanet.userData)?void 0:e.audioPlanetId;s&&this.hiddenMessages.has(s)&&this.embedHiddenMessage(a,s),this.drawStaticUI()}yToFreq(e){const n=this.spectrogramCanvas.height,t=(n-e)/n,o=Math.log10(this.minFreq),i=Math.log10(this.maxFreq);return Math.pow(10,o+t*(i-o))}dispose(){this.hideSpectrogram(),window.removeEventListener("mousemove",this.onMouseMove)}}(ze,Te);window.audioVisualizer=qe,qe.setHiddenMessage(1,"5000,100,5000"),qe.setHiddenMessage(2,"3200,0,-4500"),qe.setHiddenMessage(3,"-1000,500,8000"),qe.setHiddenMessage(4,"0,-300,0"),qe.setHiddenMessage(5,"7777,777,7777");const $e=function({scene:e,camera:n,maxDistance:t=500,fullOpacityDistance:o=100,refreshIntervalSec:i=1}={}){if(!e||!n)throw new Error("createAudioProximityHUD requires { scene, camera }.");const r=function(){let e=document.getElementById("audio-proximity-hud-root");return e||(e=document.createElement("div"),e.id="audio-proximity-hud-root",e.style.position="fixed",e.style.left="0",e.style.top="0",e.style.width="100%",e.style.height="100%",e.style.pointerEvents="none",e.style.zIndex="9999",document.body.appendChild(e),e)}(),s=ke("left"),l=ke("right");r.appendChild(s.wrapper),r.appendChild(l.wrapper);const c=new a,d=new a,u=new a,h=new a,p=new a;let f=[],v=0;const g={left:s.barEls.map(()=>({current:.5,target:.5,timer:0,speed:.8+.6*Math.random(),personality:.6+.8*Math.random()})),right:l.barEls.map(()=>({current:.5,target:.5,timer:0,speed:.8+.6*Math.random(),personality:.6+.8*Math.random()}))};function w(){f=function(e){const n=[];return e.traverse(e=>{e&&e.isMesh&&e.userData&&!0===e.userData.isAudioPlanet&&n.push(e)}),n}(e)}function y(e,n,t){const o=982.26,i=xe(.5*(t+1)),a=1-i,r=o*n*i,s=o-r;e.clipTopRect.setAttribute("y",String(s)),e.clipTopRect.setAttribute("height",String(r));const l=o*n*a;e.clipBottomRect.setAttribute("y","0"),e.clipBottomRect.setAttribute("height",String(l))}function b(e,n,t){const o=g[e];for(let i=0;i<o.length;i++){const e=o[i];if(e.timer-=n,e.timer<=0){e.timer=.12+.28*Math.random();const n=[{min:.02,max:1},{min:.02,max:1},{min:.02,max:1},{min:.02,max:1},{min:.02,max:1}][i];e.target=n.min+Math.random()*(n.max-n.min),e.target*=Math.max(.05,t)}const a=12*e.speed;e.current+=(e.target-e.current)*(1-Math.exp(-a*n))}}function x(e,n,t,o,i){const a=g[i],r=.7*t;e.barEls.forEach((e,n)=>{const t=a[n],o=t.current*t.personality,i=1+r*o*4,s=Math.min(5,Math.max(.33,i));e.style.transform=`scaleY(${s.toFixed(3)})`})}function M(e,n,t,i){let a;if(i<=o)a=1;else if(i<=150){const e=(150-i)/50,o=xe(n)*xe(t);a=m.lerp(o,1,e)}else a=xe(n)*xe(t);e.wrapper.style.opacity=String(a);const r=10*(1-n);e.wrapper.classList.contains("audio-proximity-icon--right")?e.wrapper.style.right=`${18+r}px`:e.wrapper.style.left=`${18+r}px`}return w(),{update:function(e){e||(e=0),v+=e,v>=i&&(v=0,w());const a=function(){if(!f.length)return null;h.copy(n.position);let e=null,t=1/0;for(const n of f){n.getWorldPosition(c);const o=h.distanceTo(c);o<t&&(t=o,e=n)}return e?{obj:e,dist:t}:null}();if(!a)return M(s,0,0,1/0),M(l,0,0,1/0),y(s,0,0),y(l,0,0),x(s,0,0,0,"left"),void x(l,0,0,0,"right");const r=a.dist,g=xe(1-r/t),C=Me(0,1,g);h.copy(n.position),a.obj.getWorldPosition(c),p.copy(c).sub(h).normalize(),d.set(1,0,0).applyQuaternion(n.quaternion).normalize();const k=m.clamp(p.dot(d),-1,1);u.set(0,1,0).applyQuaternion(n.quaternion).normalize();const D=m.clamp(p.dot(u),-1,1),S=Ce(xe(.5*(k+1))),P=Ce(xe(.5*(1-k))),z=Me(0,o,o-r),A=m.lerp(P,1,z),T=m.lerp(S,1,z),R=Math.max(1e-4,A+T),H=A/R,E=T/R,L=1*C;b("left",e,g),b("right",e,g),y(s,C,D),y(l,C,D),x(s,0,L,0,"left"),x(l,0,L,0,"right"),M(s,C,H,r),M(l,C,E,r)},destroy:function(){s.wrapper.parentNode&&s.wrapper.parentNode.removeChild(s.wrapper),l.wrapper.parentNode&&l.wrapper.parentNode.removeChild(l.wrapper)}}}({scene:ze,camera:Te,maxDistance:500});window.audioProximityHUD=$e;const Ye=new class{constructor(e,n,t,o,i={}){const r=new x(5,64,64);r.computeTangents();const s=new M,c=e=>{const n=s.load(e,void 0,void 0,e=>{});return n.minFilter=D,n.magFilter=S,n.generateMipmaps=!0,n.wrapS=P,n.wrapT=P,n},h=c("./textures/earth_daymap.jpg"),p=c("./textures/earth_nightmap.jpg"),f=c("./textures/earth_normal.jpg"),v=c("./textures/earth_clouds.png"),g=c("./textures/earth_specular.jpg");if(t){const e=Math.min(4,t.capabilities.getMaxAnisotropy());[h,p,f,v,g].forEach(n=>{n.anisotropy=e})}const w={lightDirection:{value:new a},dayTexture:{value:h},nightTexture:{value:p},normalMap:{value:f},specMap:{value:g},odinFactor:{value:0}},y=new l({uniforms:w,vertexShader:"\n      varying vec2 vUv;\n      varying vec3 vNormal;\n      varying vec3 vPosition;\n      varying vec3 vViewPosition;\n      varying mat3 vTBN;\n      attribute vec4 tangent;\n\n      void main() {\n        vUv = uv;\n        vNormal = normalize(normalMatrix * normal);\n        vPosition = position;\n        \n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n        vViewPosition = -mvPosition.xyz;\n\n        vec3 T = normalize(mat3(modelMatrix) * tangent.xyz);\n        vec3 N = normalize(mat3(modelMatrix) * normal);\n        vec3 B = cross(N, T);\n        vTBN = mat3(T, B, N);\n\n        gl_Position = projectionMatrix * mvPosition;\n      }\n    ",fragmentShader:"\n      uniform vec3 lightDirection;\n      uniform sampler2D dayTexture;\n      uniform sampler2D nightTexture;\n      uniform sampler2D normalMap;\n      uniform sampler2D specMap;\n      uniform float odinFactor;\n\n      varying vec2 vUv;\n      varying vec3 vNormal;\n      varying vec3 vPosition;\n      varying vec3 vViewPosition;\n      varying mat3 vTBN;\n\n      void main() {\n        // ========================================\n        // üåç NORMAL MAPPING\n        // ========================================\n        vec3 normalMapValue = (texture2D(normalMap, vUv).xyz * 2.0 - 1.0) * 0.6;\n        vec3 realNormal = normalize(vTBN * normalMapValue);\n\n        vec3 lightDir = normalize(lightDirection);\n        float nDotL = max(dot(realNormal, lightDir), 0.0);\n\n        // ========================================\n        // üåÖ YUMU≈ûAK GECE-G√úND√úZ GE√áƒ∞≈ûƒ∞\n        // ========================================\n        vec3 dayColor = texture2D(dayTexture, vUv).rgb;\n        vec3 nightColor = texture2D(nightTexture, vUv).rgb;\n        \n        float dayNightMix = smoothstep(0.0, 0.3, nDotL);\n        vec3 dayLit = dayColor * (0.3 + nDotL * 0.7);\n        vec3 nightLit = nightColor * 1.5;\n        vec3 finalColor = mix(nightLit, dayLit, dayNightMix);\n        \n        // ========================================\n        // üåü FRESNEL RIM LIGHT (Atmosfer etkisi)\n        // ========================================\n        vec3 viewDir = normalize(vViewPosition);\n        float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 3.0);\n        vec3 rimColor = vec3(0.4, 0.6, 0.9) * fresnel * 0.4;\n        finalColor += rimColor * smoothstep(0.0, 0.5, nDotL);\n        \n        // ========================================\n        // üé® ODIN'S SIGHT X-RAY MODE\n        // ========================================\n        float specSample = texture2D(specMap, vUv).r;\n        float glowMask = pow(specSample, 0.9);\n        float alphaMask = specSample;\n        \n        float darken = 0.3;\n        vec3 baseColorDark = finalColor * darken;\n        vec3 odinColor = mix(vec3(0.25, 0.6, 1.0), vec3(1.0), glowMask * 0.5);\n        float odinGlow = glowMask * 1.0;\n        \n        vec3 odinRimColor = vec3(0.3, 0.7, 1.0) * fresnel * 1.2;\n        vec3 odinResult = baseColorDark + odinGlow * odinColor + odinRimColor * odinFactor;\n        \n        finalColor = mix(finalColor, odinResult, odinFactor);\n        float finalAlpha = mix(1.0, alphaMask, odinFactor);\n        \n        \n        // ‚ú® BLOOM - Sadece aydƒ±nlƒ±k b√∂lgeye (g√ºnd√ºz tarafƒ±)\n        // nDotL > 0.2 olan yerler (g√ºn ƒ±≈üƒ±ƒüƒ± alan b√∂lgeler) bloom alacak\n        float bloomIntensity = smoothstep(0.1, 0.5, nDotL);  // Yumu≈üak ge√ßi≈ü\n        vec3 bloomColor = finalColor * bloomIntensity * 0.3;  // 0.3 = bloom g√ºc√º (ayarlanabilir)\n        \n        // Odin mode'da bloom kapalƒ±\n        bloomColor *= (1.0 - odinFactor);\n        \n        finalColor += bloomColor;\n        gl_FragColor = vec4(finalColor, finalAlpha);\n      }\n    ",lights:!1,depthWrite:!0,transparent:!0}),b=new u(r,y);b.rotation.y=m.degToRad(-180),b.rotation.z=m.degToRad(-23.4);const z=new x(5.05,64,64),A={speed:.1,direction:new d(1,.05),turbulence:.1,distortion:.05,detailScale:3,...i},T={lightDirection:{value:new a},cloudTexture:{value:v},time:{value:0},cloudSpeed:{value:A.speed},cloudDirection:{value:A.direction},cloudTurbulence:{value:A.turbulence},cloudDistortion:{value:A.distortion},cloudDetailScale:{value:A.detailScale},odinFactor:{value:0}},R=new l({uniforms:T,vertexShader:"\n      varying vec2 vUv;\n      varying vec3 vNormal;\n      varying vec3 vWorldNormal;  // ‚úÖ World space normal ekle\n\n      void main() {\n        vUv = uv;\n        \n        // ‚úÖ Model space normal (yerel)\n        vNormal = normalize(normalMatrix * normal);\n        \n        // ‚úÖ World space normal (global - rotasyonlardan etkilenmez)\n        vWorldNormal = normalize(mat3(modelMatrix) * normal);\n        \n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    ",fragmentShader:"\n      uniform vec3 lightDirection;\n      uniform sampler2D cloudTexture;\n      uniform float time;\n      uniform float cloudSpeed;\n      uniform vec2 cloudDirection;\n      uniform float cloudTurbulence;\n      uniform float cloudDistortion;\n      uniform float cloudDetailScale;\n      uniform float odinFactor;\n\n      varying vec2 vUv;\n      varying vec3 vNormal;\n      varying vec3 vWorldNormal;  // ‚úÖ World space normal\n\n      // ========================================\n      // üåä NOISE FUNCTIONS\n      // ========================================\n      float hash(vec2 p) {\n        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n      }\n      \n      float noise(vec2 p) {\n        vec2 i = floor(p);\n        vec2 f = fract(p);\n        f = f * f * (3.0 - 2.0 * f);\n        \n        float a = hash(i);\n        float b = hash(i + vec2(1.0, 0.0));\n        float c = hash(i + vec2(0.0, 1.0));\n        float d = hash(i + vec2(1.0, 1.0));\n        \n        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n      }\n      \n      float fbm(vec2 p) {\n        float value = 0.0;\n        float amplitude = 0.5;\n        float frequency = 1.0;\n        \n        for(int i = 0; i < 4; i++) {\n          value += amplitude * noise(p * frequency);\n          frequency *= 2.0;\n          amplitude *= 0.5;\n        }\n        \n        return value;\n      }\n      \n      float turbulence(vec2 p) {\n        float t = 0.0;\n        float amplitude = 1.0;\n        float frequency = 1.0;\n        \n        for(int i = 0; i < 3; i++) {\n          t += amplitude * abs(noise(p * frequency));\n          frequency *= 2.0;\n          amplitude *= 0.5;\n        }\n        \n        return t;\n      }\n\n      void main() {\n        // ‚úÖ WORLD SPACE'de ƒ±≈üƒ±k hesaplama (rotasyondan etkilenmez)\n        vec3 lightDir = normalize(lightDirection);\n        float nDotL = max(dot(normalize(vWorldNormal), lightDir), 0.0);\n        \n        // ========================================\n        // ‚òÅÔ∏è FRACTAL BULUTLAR\n        // ========================================\n        vec2 baseFlow = vUv + (cloudDirection * time * cloudSpeed * 0.005);\n        \n        float distortion1 = fbm(vUv * cloudDetailScale + time * 0.008);  // 3x daha yava≈ü\n        float distortion2 = fbm(vUv * cloudDetailScale * 0.5 - time * 0.005);  // 3x daha yava≈ü\n        vec2 distortionOffset = vec2(distortion1, distortion2) * cloudDistortion;\n        \n        float turbulenceValue = turbulence(vUv * cloudDetailScale * 2.0 + time * 0.012);  // 3x daha yava≈ü\n        vec2 turbulenceOffset = vec2(\n          sin(turbulenceValue * 3.14159),\n          cos(turbulenceValue * 3.14159)\n        ) * cloudTurbulence * 0.02;\n        \n        vec2 cloudUV = baseFlow + distortionOffset + turbulenceOffset;\n        vec4 cloudSample = texture2D(cloudTexture, fract(cloudUV));\n        \n        float proceduralDetail = fbm(cloudUV * cloudDetailScale * 3.0);\n        cloudSample.rgb = mix(cloudSample.rgb, vec3(proceduralDetail), 0.12);  // Daha az detay\n        \n        float cloudDensity = dot(cloudSample.rgb, vec3(0.299, 0.587, 0.114));\n        float cloudAlpha = smoothstep(0.40, 0.80, cloudDensity);  // Daha y√ºksek threshold = daha az bulut\n        \n        // ‚òÄÔ∏è Bulut rengi - parlak beyaz\n        float cloudBrightness = 0.85 + nDotL * 0.15;\n        vec3 cloudColor = vec3(1.0) * cloudBrightness;\n        \n        // üåë G√∂lge efekti - sadece g√ºne≈üe baƒülƒ±\n        float cloudShadow = smoothstep(0.0, 0.2, nDotL);\n        cloudColor *= (0.7 + cloudShadow * 0.3);\n        \n        // ‚úÖ Atmosfer efekti KALDIRILDI - artƒ±k kameraya baƒülƒ± deƒüil\n        \n        // Gece tarafƒ±nda bulutlar kaybolsun (sadece g√ºne≈ü ƒ±≈üƒ±ƒüƒ±na baƒülƒ±)\n        float dayNightMix = smoothstep(0.0, 0.3, nDotL);\n        \n        // ========================================\n        // üé® ODIN MODE - Bulutlar kaybolur\n        // ========================================\n        float finalAlpha = cloudAlpha * dayNightMix * (1.0 - odinFactor);\n        \n        gl_FragColor = vec4(cloudColor, finalAlpha);\n      }\n    ",transparent:!0,depthWrite:!1,side:C}),H=new u(z,R);H.rotation.y=m.degToRad(-180),H.rotation.z=m.degToRad(-23.4);const E=new k;E.add(b),E.add(H),E.position.copy(e),E.userData.earthUniforms=w,E.userData.cloudUniforms=T,E.userData.earthMesh=b,E.userData.cloudMesh=H,o.add(E),this.group=E,this.earthMesh=b,this.cloudMesh=H,this.earthUniforms=w,this.cloudUniforms=T,this.startTime=Date.now()}animate(){this.cloudMesh&&(this.cloudUniforms.time.value=(Date.now()-this.startTime)/1e3,this.cloudMesh.rotation.y+=1e-4)}get object(){return this.group}get mesh(){return this.earthMesh}}(ue.clone(),()=>Ve.position.clone().negate(),Ae,ze,{speed:.6,direction:new d(1,.05),turbulence:.25,distortion:.12,detailScale:6});window.earth=Ye;const Ke=Ye.object;Ke.userData.ignoreScan=!0;const Xe=new class{constructor(e,n,t,o){const i=new x(1,64,64);i.computeTangents();const r=new M,s=e=>r.load(e,void 0,void 0,e=>{}),c=s("./textures/moon.png"),d=s("./textures/moon_normal.png"),h=s("./textures/moon_spec_xray.png");if(t){const e=Math.min(4,t.capabilities.getMaxAnisotropy());c.anisotropy=e,d.anisotropy=e,h.anisotropy=e}const m={moonIllumination:{value:oe.getMoonIllumination(new Date).fraction},lightDirection:{value:new a},moonTexture:{value:c},normalMap:{value:d},glowPower:{value:.25},glowSoftness:{value:1},specMap:{value:h},odinFactor:{value:0}},p=new l({uniforms:m,vertexShader:"\n      varying vec2 vUv;\n      varying vec3 vViewPosition;\n      varying vec3 vNormal;\n      varying mat3 vTBN;\n      attribute vec4 tangent;\n\n      void main() {\n        vUv = uv;\n        vNormal = normalize(normalMatrix * normal);\n        \n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n        vViewPosition = -mvPosition.xyz;\n\n        vec3 T = normalize(mat3(modelMatrix) * tangent.xyz);\n        vec3 N = normalize(mat3(modelMatrix) * normal);\n        vec3 B = cross(N, T);\n        vTBN = mat3(T, B, N);\n\n        gl_Position = projectionMatrix * mvPosition;\n      }\n    ",fragmentShader:"\n      uniform float moonIllumination;\n      uniform vec3 lightDirection;\n      uniform sampler2D moonTexture;\n      uniform sampler2D normalMap;\n      uniform float glowPower;\n      uniform float glowSoftness;\n      uniform sampler2D specMap;\n      uniform float odinFactor;\n\n      varying vec2 vUv;\n      varying vec3 vViewPosition;\n      varying vec3 vNormal;\n      varying mat3 vTBN;\n\n      void main() {\n        vec3 normalMapValue = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;\n        vec3 realNormal = normalize(vTBN * normalMapValue);\n\n        vec3 lightDir = normalize(lightDirection);\n        float nDotL = max(dot(realNormal, lightDir), 0.0);\n\n        vec4 texColor = texture2D(moonTexture, vUv);\n        \n        // ========================================\n        // üåô KESKƒ∞N AY FAZI (daha belirgin ama daha parlak)\n        // ========================================\n        float phaseSharpness = 2.0; // Biraz daha yumu≈üak (2.5'ten 2.0'a)\n        float phaseFactor = pow(nDotL, phaseSharpness) * moonIllumination;\n        \n        // Daha aydƒ±nlƒ±k ambient\n        float ambientMoon = 0.2; // Arttƒ±rƒ±ldƒ± (0.01'den 0.05'e)\n        vec3 ambient = texColor.rgb * ambientMoon;\n        vec3 lit = texColor.rgb * phaseFactor * 1.3; // %30 daha parlak\n        \n        // Smooth transition\n        float dayNightMix = smoothstep(0.0, 0.25, phaseFactor); // Daha yumu≈üak ge√ßi≈ü\n        vec3 litBase = mix(ambient, lit, dayNightMix);\n\n        // Glow - daha belirgin\n        float rawGlow = phaseFactor * glowSoftness;\n        float glow = smoothstep(0.2, 0.8, rawGlow); // Daha erken ba≈ülayan glow\n        vec3 normalLitColor = litBase + glow * vec3(0.95, 0.9, 0.85) * moonIllumination * 1.2; // %20 daha parlak glow\n\n        // ========================================\n        // üåü Fresnel Effect (Rim Lighting) - daha parlak\n        // ========================================\n        vec3 viewDir = normalize(vViewPosition);\n        float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 3.0);\n        vec3 rimColor = vec3(0.7, 0.75, 0.85) * fresnel * 0.35; // Daha parlak rim\n        normalLitColor += rimColor * dayNightMix; // Sadece aydƒ±nlƒ±k tarafta\n\n        // Spec map: siyah (kraterler) = 0.0, beyaz (d√ºz alanlar) = 1.0\n        float specSample = texture2D(specMap, vUv).r;\n        \n        // ========================================\n        // üé® Yumu≈üak Blend: Normal ‚Üî Odin\n        // ========================================\n        \n        // glowMask: siyah alanlar (kraterler) parlasƒ±n\n        float glowMask = pow(1.0 - specSample, 0.9);\n        \n        // alphaMask: siyah alanlar g√∂r√ºns√ºn, beyaz alanlar transparan\n        float alphaMask = 1.0 - specSample;\n        \n        // Odin color'u hazƒ±rla\n        float darken = 0.4;\n        vec3 baseColorDark = normalLitColor * darken;\n        vec3 odinColor = mix(\n          vec3(0.25, 0.6, 1.0),\n          vec3(1.0),\n          glowMask * 0.5\n        );\n        float odinGlow = glowMask * 2.0;\n        \n        // Odin modunda rim light daha belirgin\n        vec3 odinRimColor = vec3(0.3, 0.7, 1.0) * fresnel * 1.5;\n        vec3 odinResult = baseColorDark + odinGlow * odinColor + odinRimColor * odinFactor;\n        \n        // Normal ve Odin arasƒ±nda yumu≈üak ge√ßi≈ü\n        vec3 finalColor = mix(normalLitColor, odinResult, odinFactor);\n        \n        // Alpha da yumu≈üak ge√ßi≈ü\n        float finalAlpha = mix(1.0, alphaMask, odinFactor);\n        \n        gl_FragColor = vec4(finalColor, finalAlpha);\n      }\n    ",lights:!1,depthWrite:!1,transparent:!0}),f=new u(i,p);f.position.copy(e),o.add(f),this.mesh=f,this.material=p,this.uniforms=m}get object(){return this.mesh}}(ue.clone(),()=>Ve.position.clone().negate(),Ae,ze);window.moon=Xe;const Ze=Xe.object;Ze.userData.ignoreScan=!0;const Qe=[];(null==(n=null==(e=null==Ke?void 0:Ke.userData)?void 0:e.earthUniforms)?void 0:n.odinFactor)&&Qe.push(Ke.userData.earthUniforms.odinFactor),(null==(o=null==(t=null==Ke?void 0:Ke.userData)?void 0:t.cloudUniforms)?void 0:o.odinFactor)&&Qe.push(Ke.userData.cloudUniforms.odinFactor);const Je=Array.isArray(Ze.material)?Ze.material[0]:Ze.material;(null==(i=null==Je?void 0:Je.uniforms)?void 0:i.odinFactor)&&Qe.push(Je.uniforms.odinFactor);const en=function(e,n,t,o){he={enabled:e,lensPosition:n??new a(25,2,-40),opacity:t,colorGain:o??new r(95,12,10),visible:!0,isDaytime:!0,baseScale:1,minOcclusionFactor:.05};const i=he.lensPosition,p=new s,f=he.opacity;let v=f,g=new a,w=1,y=1;const b=function(e){const n=[],t=(e-1)/2;n.push({x:0,y:0});for(let o=0;o<e;o++)for(let i=0;i<e;i++){const e=(i-t)/t,a=(o-t)/t;if(0===e&&0===a)continue;e*e+a*a<=1&&n.push({x:e,y:a})}return n}(7),x=3500,M=new l({uniforms:{iTime:{value:0},iResolution:{value:new d(window.innerWidth,window.innerHeight)},lensPosition:{value:new d(0,0)},enabled:{value:he.enabled},colorGain:{value:he.colorGain},opacity:{value:v},isDaytime:{value:!0},distanceScale:{value:1},occlusionFactor:{value:1},flareScale:{value:he.baseScale}},fragmentShader:"uniform vec2 iResolution;\r\nuniform float iTime;\r\nuniform vec2 lensPosition;\r\nuniform bool isDaytime;\r\nuniform float opacity;\r\nuniform float occlusionFactor;\r\nuniform float flareScale; \n\nfloat hash(float n) {\r\n    return fract(sin(n) * 43758.5453123);\r\n}\n\nfloat hash(vec2 p) {\r\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\r\n}\n\nvec3 lensflare(vec2 uv, vec2 pos, float scale)\r\n{\r\n    \n    \n    float invScale = 1.0 / scale;\r\n    \r\n    \n    vec2 scaledUV = pos + (uv - pos) * invScale;\r\n    vec2 scaledUVD = scaledUV * length(scaledUV);\r\n    \r\n    vec2 main = scaledUV - pos;\r\n    \r\n    float ang = atan(main.x, main.y);\r\n    float dist = length(main); \r\n    dist = pow(dist, .1);\r\n    float n = hash(vec2(ang * 16.0, dist * 32.0));\r\n    \r\n    \n    float f0 = 1.0 / (length(scaledUV - pos) * 16.0 + 1.0);\r\n    f0 += f0 * (sin(hash(sin(ang * 2. + pos.x) * 4.0 - cos(ang * 3. + pos.y)) * 16.0) * 0.1 + dist * 0.1 + 0.8);\r\n    \r\n    \n    float f2 = max(1.0 / (1.0 + 32.0 * pow(length(scaledUVD + 0.8 * pos), 2.0)), 0.0) * 0.25;\r\n    float f22 = max(1.0 / (1.0 + 32.0 * pow(length(scaledUVD + 0.85 * pos), 2.0)), 0.0) * 0.23;\r\n    float f23 = max(1.0 / (1.0 + 32.0 * pow(length(scaledUVD + 0.9 * pos), 2.0)), 0.0) * 0.21;\n\n    vec2 uvx = mix(scaledUV, scaledUVD, -0.5);\n\n    float f4 = max(0.01 - pow(length(uvx + 0.4 * pos), 2.4), 0.0) * 6.0;\r\n    float f42 = max(0.01 - pow(length(uvx + 0.45 * pos), 2.4), 0.0) * 5.0;\r\n    float f43 = max(0.01 - pow(length(uvx + 0.5 * pos), 2.4), 0.0) * 3.0;\n\n    uvx = mix(scaledUV, scaledUVD, -0.4);\r\n    float f5 = max(0.01 - pow(length(uvx + 0.2 * pos), 5.5), 0.0) * 2.0;\r\n    float f52 = max(0.01 - pow(length(uvx + 0.4 * pos), 5.5), 0.0) * 2.0;\r\n    float f53 = max(0.01 - pow(length(uvx + 0.6 * pos), 5.5), 0.0) * 2.0;\n\n    uvx = mix(scaledUV, scaledUVD, -0.5);\r\n    float f6 = max(0.01 - pow(length(uvx - 0.3 * pos), 1.6), 0.0) * 6.0;\r\n    float f62 = max(0.01 - pow(length(uvx - 0.325 * pos), 1.6), 0.0) * 3.0;\r\n    float f63 = max(0.01 - pow(length(uvx - 0.35 * pos), 1.6), 0.0) * 5.0;\n\n    vec3 c = vec3(0.0);\r\n    c.r += f2 + f4 + f5 + f6;\r\n    c.g += f22 + f42 + f52 + f62;\r\n    c.b += f23 + f43 + f53 + f63;\n\n    c = c * 1.3 - vec3(length(scaledUVD) * 0.05);\r\n    c += vec3(f0);\r\n    \r\n    return c;\r\n}\n\nvec3 cc(vec3 color, float factor, float factor2) {\r\n    float w = color.x + color.y + color.z;\r\n    return mix(color, vec3(w) * factor, w * factor2);\r\n}\n\nvoid main() {\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy - 0.5;\r\n    uv.x *= iResolution.x / iResolution.y;\n\n    \n    vec3 color = vec3(1.4, 1.2, 1.0) * lensflare(uv, lensPosition, flareScale);\r\n    color -= hash(gl_FragCoord.xy) * 0.015;\r\n    color = cc(color, 0.5, 0.1);\n\n    \n    color *= occlusionFactor;\r\n    \r\n    \n    float finalAlpha = opacity * occlusionFactor;\r\n    \r\n    \n    if (finalAlpha < 0.01) {\r\n        discard;\r\n    }\n\n    gl_FragColor = vec4(color, finalAlpha);\r\n}",vertexShader:"varying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = vec4(position, 1.0);\r\n}",transparent:!0,depthWrite:!1,depthTest:!1,blending:c,name:"LensFlareShader"}),C=new u(new h(2,2),M);C.userData.noOcclusion=!0,C.userData.isLensFlare=!0,C.frustumCulled=!1;const k=new a,D=new a,S=new a,P=new a,z=new a,A=new a,T=new a;new a,new a;const R=new a,H=new a;function E(e,n){w=y,M.uniforms.occlusionFactor.value=w,v=f*w,M.uniforms.lensPosition.value.set(g.x,g.y),M.uniforms.opacity.value=v,M.uniforms.flareScale.value=he.baseScale,M.uniforms.isDaytime.value=he.isDaytime}function L(e,n,t,o){T.subVectors(n,e).normalize();const i=e.distanceTo(n);for(const r of o){const n=e.distanceTo(r.position);if(n>i)continue;const t=(new a).subVectors(r.position,e).normalize(),o=T.dot(t);if(Math.acos(Math.max(-1,Math.min(1,o)))<Math.atan2(r.radius,n))return!0}return!1}return M.onBeforeRender=function(e,n,t){if(!he.visible||!he.enabled)return M.uniforms.opacity.value=0,M.uniforms.occlusionFactor.value=0,void(v=0);const o=performance.now()/1e3;e.getCurrentViewport(p),M.uniforms.iResolution.value.set(p.z,p.w),M.uniforms.iTime.value=o,D.copy(i),k.copy(t.position);const r=k.distanceTo(D),s=D.clone().project(t);if(s.z>1)return y=0,void E();g.set(s.x,s.y,s.z),C.lookAt(t.position);const l=new a;t.getWorldDirection(l),S.subVectors(D,k).normalize();const c=l.dot(S);if(c>.3&&he.isDaytime){const e=m.smoothstep(c,.3,.7),t=function(e,n,t){S.subVectors(D,k).normalize();const o=.04*t,i=Math.abs(S.y)<.9?new a(0,1,0):new a(1,0,0);P.crossVectors(S,i).normalize(),z.crossVectors(P,S).normalize();const r=function(e,n){const t=[];return e.traverse(e=>{var o,i,a,r,s,l;if(e.isGroup){if(!0===(null==(o=e.userData)?void 0:o.noOcclusion))return;if(!0===(null==(i=e.userData)?void 0:i.ignoreScan))return;const a=[];if(e.traverse(e=>{var n,t;if(e.isMesh&&e.visible&&e.geometry){if(!0===(null==(n=e.userData)?void 0:n.noOcclusion))return;if(!0===(null==(t=e.userData)?void 0:t.ignoreScan))return;a.push(e)}}),0===a.length)return;e.getWorldPosition(R);let r=0;if(a.forEach(e=>{e.geometry.boundingSphere||e.geometry.computeBoundingSphere();const n=e.geometry.boundingSphere;if(!n)return;e.getWorldScale(H);const t=n.radius*Math.max(H.x,H.y,H.z);t>r&&(r=t)}),r<.5)return;const s=k.distanceTo(R);if(s>x)return;if(s>1.1*n)return;if(R.clone().sub(k).dot(S)<0)return;return void t.push({position:R.clone(),radius:r,distance:s,type:"group",name:e.name||"unnamed-group"})}if(!e.isMesh)return;if(!e.visible)return;if(!0===(null==(a=e.userData)?void 0:a.noOcclusion))return;if(!0===(null==(r=e.userData)?void 0:r.isLensFlare))return;if(!0===(null==(s=e.userData)?void 0:s.ignoreScan))return;if(!e.geometry)return;if(e.material){const n=Array.isArray(e.material)?null==(l=e.material[0])?void 0:l.opacity:e.material.opacity;if(void 0!==n&&n<.1)return}if(e.parent&&e.parent.isGroup)return;e.geometry.boundingSphere||e.geometry.computeBoundingSphere();const c=e.geometry.boundingSphere;if(!c)return;e.getWorldScale(H);const d=c.radius*Math.max(H.x,H.y,H.z);if(d<.5)return;e.getWorldPosition(R);const u=k.distanceTo(R);if(u>x)return;if(u>1.1*n)return;R.clone().sub(k).dot(S)<0||t.push({position:R.clone(),radius:d,distance:u,type:"mesh",name:e.name||"unnamed-mesh"})}),t.sort((e,n)=>e.distance-n.distance),t}(e,t);if(0===r.length)return 1;let s=0;const l=b.length;for(let a=0;a<l;a++){const e=b[a];A.copy(D).addScaledVector(P,e.x*o).addScaledVector(z,e.y*o),L(k,A,t,r)||s++}const c=s/l,d=he.minOcclusionFactor;return d+(1-d)*c}(n,0,r);y=e*t}else y=0;E()},C}(!0,Ve.position,.8,new r(95,12,10));ze.add(en),window.lensFlareEffect=en,window.LensFlareParams=window.LensFlareParams||{};const nn=new class{constructor(e,n,t=new a(0,0,0)){this.scene=e,this.camera=n,this.solarSystemOffset=t,this.planets=[],this.raycaster=new b,this.mouse=new d,this.tooltip=this._createTooltip(),this.clock=new W,this.fadeDuration=1.5,window.addEventListener("mousemove",e=>this._onMouseMove(e)),window.addEventListener("click",()=>this._onClick()),this._fetchNews(),setInterval(()=>this._fetchNews(),6e4)}async _fetchNews(){try{const e=await fetch("https://gnews.io/api/v4/top-headlines?lang=en&max=30&token=9aacb4113ed0c8a45c324a35016ac78c"),n=await e.json();if(!n.articles)return;this._clearPlanets(),this._createPlanets(n.articles)}catch(e){}}_createPlanets(e){const n=3e3;for(let t of e){const o=new x(10+5*Math.random(),32,32);o.computeBoundingSphere();const i=(new r).setHSL(.33,1,.4+.2*Math.random()),s=new G({color:i,emissive:i.clone().multiplyScalar(.3),roughness:.5,metalness:.2,transparent:!0,opacity:0}),l=new u(o,s),c=e.indexOf(t);let d;l.name=`NewsPlanet-${c}`;let h=0;do{d=new a(m.randFloatSpread(n)+this.solarSystemOffset.x,m.randFloatSpread(n)+this.solarSystemOffset.y,m.randFloatSpread(n)+this.solarSystemOffset.z),h++}while(this.planets.some(e=>e.mesh.position.distanceTo(d)<500)&&h<50);l.position.copy(d),l.userData={url:t.url,title:t.title,description:t.description||"No summary available",fadeState:"in",fadeProgress:0,targetOpacity:1,isNewsPlanet:!0},this.scene.add(l),this.planets.push({mesh:l})}}_clearPlanets(){for(const{mesh:e}of this.planets)"out"!==e.userData.fadeState&&(e.userData.fadeState="out",e.userData.fadeProgress=0)}_createTooltip(){const e=document.createElement("div");return e.style.position="absolute",e.style.background="rgba(0, 100, 0, 0.85)",e.style.color="#fff",e.style.padding="8px",e.style.borderRadius="6px",e.style.pointerEvents="none",e.style.display="none",e.style.maxWidth="300px",e.style.fontFamily="Arial",e.style.fontSize="12px",document.body.appendChild(e),e}_onMouseMove(e){this.mouse.x=e.clientX/window.innerWidth*2-1,this.mouse.y=-e.clientY/window.innerHeight*2+1,this.raycaster.setFromCamera(this.mouse,this.camera);const n=this.raycaster.intersectObjects(this.planets.map(e=>e.mesh));if(n.length>0){const t=n[0].object,{title:o,description:i}=t.userData;this.tooltip.style.display="block",this.tooltip.style.left=`${e.clientX+15}px`,this.tooltip.style.top=`${e.clientY+15}px`,this.tooltip.innerHTML=`<strong>${o}</strong><br>${i}`,this.hovered=t}else this.tooltip.style.display="none",this.hovered=null}_onClick(){this.hovered&&window.open(this.hovered.userData.url,"_blank")}update(e=.016){for(let n=this.planets.length-1;n>=0;n--){const{mesh:t}=this.planets[n],o=t.userData;if("in"===o.fadeState){o.fadeProgress+=e/this.fadeDuration,o.fadeProgress>=1&&(o.fadeProgress=1,o.fadeState="visible");const n=this._easeInOutCubic(o.fadeProgress);t.material.opacity=n*o.targetOpacity}else if("out"===o.fadeState){if(o.fadeProgress+=e/this.fadeDuration,o.fadeProgress>=1){this.scene.remove(t),this.planets.splice(n,1);continue}const i=this._easeInOutCubic(o.fadeProgress);t.material.opacity=(1-i)*o.targetOpacity}}}_easeInOutCubic(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}}(ze,Te,ue);window.newsPlanetManager=nn;const tn={realTime:!0,hour:12,minute:0,second:0,simulationSpeed:1},on={speed:.5,direction:new d(1,.05)};let an=0;const rn=[],sn={spawnInterval:15,baseSpeed:500,speedBoost:1.5,spawnXRange:30,tailLength:1,bloomIntensity:3,coreColor:"#ff0000",tailColor:"#fff8c7"},ln={x:0,y:0,z:0,ra:"0h 0m",dec:"0¬∞"},cn=function({scene:e,camera:n,bloomPass:t,maxRadius:o=300,duration:i=2,waveSpeed:s=150,waveThickness:d=20,odinUniforms:h=[]}={}){const p={active:!1,startTime:0,currentRadius:0,progress:0,bloomTriggered:!1,bloomStartProgress:0,scanId:0},f=new a,v=new a,g=Array.isArray(h)?h:[],w=[],y=[],b=[],M=new Set,C=n.userData.audioListener,k=new _;let D=null,S=!1;k.load("/sounds/scan.mp3",e=>{D=new q(C),D.setBuffer(e),D.setLoop(!1),D.setVolume(.7),S=!0},void 0,e=>{S=!1});const P=new l({uniforms:{time:{value:0},progress:{value:0},baseColor:{value:new r(26367)},glowColor:{value:new r(65535)},thickness:{value:d},maxRadius:{value:o},origin:{value:new a}},vertexShader:"\n      varying vec3 vWorldPosition;\n      varying vec2 vUv;\n      \n      void main() {\n        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    ",fragmentShader:"\n      uniform float time;\n      uniform float progress;\n      uniform vec3 baseColor;\n      uniform vec3 glowColor;\n      uniform float thickness;\n      uniform float maxRadius;\n      uniform vec3 origin;\n      \n      varying vec3 vWorldPosition;\n      varying vec2 vUv;\n      \n      void main() {\n        vec3 toCenter = vWorldPosition - origin;\n        float dist = length(toCenter);\n        float waveFront = progress * maxRadius;\n        float distanceToWave = abs(dist - waveFront);\n        \n        if (distanceToWave < thickness) {\n          float intensity = 1.0 - (distanceToWave / thickness);\n          \n          float ring1 = sin(dist * 0.1 - time * 8.0) * 0.5 + 0.5;\n          float ring2 = cos(dist * 0.05 - time * 6.0) * 0.5 + 0.5;\n          float ring3 = sin(vUv.x * 20.0 + time * 10.0) * 0.3 + 0.7;\n          \n          vec3 color = mix(baseColor, glowColor, ring1 * ring2);\n          color = mix(color, vec3(1.0), ring3 * 0.3);\n          \n          float alpha = intensity * (1.0 - progress) * 0.6;\n          alpha *= ring1 * 0.8 + 0.2;\n          \n          gl_FragColor = vec4(color * intensity, alpha);\n        } else {\n          discard;\n        }\n      }\n    ",transparent:!0,side:E,depthWrite:!1,depthTest:!0,blending:c}),z=new x(1,48,32),A=new u(z,P);A.visible=!1,A.renderOrder=1e3,e.add(A);const T=(null==t?void 0:t.strength)??.7;function R(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}return{trigger:function(){p.active||(p.scanId+=1,p.active=!0,p.startTime=Date.now(),p.currentRadius=0,p.progress=0,p.bloomTriggered=!1,p.bloomStartProgress=0,f.copy(n.position),A.position.copy(f),A.visible=!0,A.scale.set(1,1,1),P.uniforms.origin.value.copy(f),t&&(t.strength=T),w.length=0,y.length=0,b.length=0,e.traverse(e=>{var n,t,o;(null==e?void 0:e.isMesh)&&!0===(null==(n=e.userData)?void 0:n.isAudioPlanet)&&(null==(t=e.userData)?void 0:t.odinUniform)&&(null==(o=e.userData)?void 0:o.revealUniform)&&(w.push(e.userData.odinUniform),y.push(e.userData.revealUniform),b.push(e))}),S&&D&&(D.isPlaying&&D.stop(),"suspended"===C.context.state?C.context.resume().then(()=>{D.play()}):D.play()),g.forEach(e=>e&&(e.value=0)),w.forEach((e,n)=>{var t;if(!e)return;const o=b[n],i=y[n];if(!o||!i)return;!0===(null==(t=o.userData)?void 0:t.discovered)||M.has(o.uuid)?(o.visible=!0,i.value=1,e.value=1):(o.visible=!1,i.value=0,e.value=0)}))},update:function(a){if(!p.active)return;const r=(Date.now()-p.startTime)/1e3;if(p.progress=Math.min(r/i,1),p.currentRadius=p.progress*o,p.progress>=1)return void function(){p.active=!1,A.visible=!1,t&&(t.strength=T);g.forEach(e=>e&&(e.value=0)),w.forEach((e,n)=>{if(!e)return;const t=b[n];t&&M.has(t.uuid)?e.value=1:e.value=0})}();const s=p.currentRadius;A.scale.set(s,s,s),P.uniforms.progress.value=p.progress,P.uniforms.time.value=r,P.uniforms.origin.value.copy(f),function(){let n=!1;return e.traverse(e=>{var t;if(!e.isMesh)return;if(null==(t=e.userData)?void 0:t.ignoreScan)return;e.getWorldPosition(v);const o=f.distanceTo(v);Math.abs(o-p.currentRadius)<d&&(n=!0)}),n}()&&!p.bloomTriggered&&(p.bloomTriggered=!0,p.bloomStartProgress=p.progress),function(){if(!t)return;const e=T;if(!p.bloomTriggered)return void(t.strength=e);const n=p.bloomStartProgress,o=1,i=1+.5*(1-(a=m.clamp((p.progress-n)/(o-n),0,1),1-(1-a)*(1-a)));var a;t.strength=e*i}(),function(){const e=R(p.progress),t=Math.sin(e*Math.PI);g.forEach(e=>e&&(e.value=t));const o=Date.now(),i=200,a=450,r=900,s=new $,l=new Y;l.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),s.setFromProjectionMatrix(l),w.forEach((e,t)=>{var l;if(!e)return;const c=b[t],d=y[t];if(!c||!d)return;if(!0===(null==(l=c.userData)?void 0:l.discovered)||M.has(c.uuid))return c.visible=!0,d.value=1,void(e.value=1);{c.getWorldPosition(v);const t=n.position.distanceTo(v),r=f.distanceTo(v),l=Math.abs(r-p.currentRadius),u=s.containsPoint(v),h=v.clone().project(n),m=Math.abs(h.x)<.7&&Math.abs(h.y)<.7;if(!(t<=i&&l<a&&u&&m))return d.value=0,c.visible=!1,void(e.value=0);M.add(c.uuid),c.userData.discovered=!0,c.userData._scanLastId!==p.scanId&&(c.userData._scanLastId=p.scanId,c.userData._revealStartMs=o,c.visible=!0,d.value=1,e.value=0)}const u=c.userData._revealStartMs;if("number"==typeof u){const n=m.clamp((o-u)/r,0,1),t=R(n);e.value=t,n>=1&&(e.value=1,delete c.userData._revealStartMs)}})}()},dispose(){P.dispose(),z.dispose(),e.remove(A),D&&(D.isPlaying&&D.stop(),D.disconnect(),D=null)},get isActive(){return p.active},get discoveredCount(){return M.size}}}({scene:ze,camera:Te,bloomPass:Fe,maxRadius:300,duration:2,waveSpeed:200,waveThickness:20,odinUniforms:Qe});function dn(){const e=Te.userData.audioListener;if(e&&"suspended"===e.context.state&&e.context.resume().then(()=>{}).catch(e=>{}),window.audioVisualizer&&window.audioVisualizer.audioContext&&"suspended"===window.audioVisualizer.audioContext.state&&window.audioVisualizer.audioContext.resume().then(()=>{}).catch(e=>{}),window.AudioContext||window.webkitAudioContext){(window.__audioContexts||[]).forEach(e=>{"suspended"===e.state&&e.resume().then(()=>{}).catch(e=>{})})}window.removeEventListener("click",dn),window.removeEventListener("keydown",dn),window.removeEventListener("touchstart",dn)}!function({gridHelper:e,axesHelper:n,sunHelper:t,moonHelper:o,sunLight:i,LensFlareParams:a,timeParams:r,moonMesh:s,moonGlowSprite:l,bloomPass:c,backgroundMaterial:d,starGroup:u,starParams:h,shootingStars:m,cameraData:p,cosmicManager:f}){var v,g,w;const y=new ne;y.close();const b=y.addFolder("Visual Helpers");b.add(e,"visible").name("Show Grid"),b.add(n,"visible").name("Show Axes"),u&&b.add(u,"visible").name("Show Static Stars");const x=y.addFolder("Light Helpers");x.add(t,"visible").name("Sun Helper"),x.add(o,"visible").name("Moon Helper");const M=y.addFolder("Time Control");M.add(r,"realTime").name("Real Time Mode"),M.add(r,"hour",0,23,1).name("Hour"),M.add(r,"minute",0,59,1).name("Minute"),M.add(r,"second",0,59,1).name("Second");const C=y.addFolder("Celestial Bodies");if(C.add(i,"intensity",0,5).name("Sun Intensity"),void 0!==(null==(v=null==a?void 0:a.enabled)?void 0:v.value)){const e=C.addFolder("Sun Flare");e.add(a.enabled,"value").name("Enabled"),e.add(a.opacity,"value",0,1).name("Opacity")}const k=y.addFolder("Moon Effects");k.add(s.scale,"x",.5,5).name("Scale").onChange(e=>s.scale.set(e,e,e)),(null==(w=null==(g=s.material)?void 0:g.uniforms)?void 0:w.glowPower)&&k.add(s.material.uniforms.glowPower,"value",0,2).name("Glow Power"),k.add(c,"strength",0,5).name("Bloom Strength");const D=y.addFolder("Global Effects");if(D.add(c,"radius",0,2).name("Bloom Radius"),D.add(c,"threshold",0,1).name("Bloom Threshold"),p){const e=y.addFolder("üìç Kamera Koordinatlarƒ±");e.add(p,"x").name("X").listen(),e.add(p,"y").name("Y").listen(),e.add(p,"z").name("Z").listen(),e.add(p,"ra").name("RA").listen(),e.add(p,"dec").name("Dec").listen()}}({gridHelper:Ie,axesHelper:Ue,sunHelper:je,moonHelper:_e,sunLight:Ve,LensFlareParams:window.LensFlareParams,timeParams:tn,moonMesh:Ze,moonGlowSprite:null,bloomPass:Fe,backgroundMaterial:null,starParams:sn,cameraData:ln,cosmicManager:Ge.cosmicManager}),function(e,n={}){let t=n.key||"Space";const o=n.allowRepeat||!1;function i(n){if(n.code===t){if(!o&&n.repeat)return;n.preventDefault(),e.trigger()}}window.addEventListener("keydown",i)}(cn),window.addEventListener("click",dn),window.addEventListener("keydown",dn),window.addEventListener("touchstart",dn);const un=new W;!function(e,n,t){function o(){}window.findCosmicObjects=function(){const e={loadedChunks:t.chunks.size,cosmicChunks:t.cosmicManager.objects.size,activeCosmicObjects:t.cosmicManager.activeObjects.size,blackholes:[],nebulas:[]};return t.cosmicManager.activeObjects.forEach(t=>{t.eventHorizon?e.blackholes.push({object:t,position:t.group.position,distance:n.position.distanceTo(t.group.position)}):t.layers&&e.nebulas.push({object:t,position:t.group.position,distance:n.position.distanceTo(t.group.position)})}),e.blackholes.sort((e,n)=>e.distance-n.distance),e.nebulas.sort((e,n)=>e.distance-n.distance),e},window.findBlackHoles=function(){const e=[];return t.cosmicManager.activeObjects.forEach(t=>{t.eventHorizon&&e.push({object:t,group:t.group,position:t.group.position.clone(),distance:n.position.distanceTo(t.group.position)})}),e.sort((e,n)=>e.distance-n.distance),e},window.findNebulas=function(){const e=[];return t.cosmicManager.activeObjects.forEach(t=>{t.layers&&e.push({object:t,group:t.group,position:t.group.position.clone(),distance:n.position.distanceTo(t.group.position)})}),e.sort((e,n)=>e.distance-n.distance),e},window.findAudioPlanets=function(){const t=[];return e.traverse(e=>{var o;!0===(null==(o=e.userData)?void 0:o.isAudioPlanet)&&t.push({mesh:e,planetId:e.userData.audioPlanetId,position:e.position.clone(),discovered:e.userData.discovered||!1,distance:n.position.distanceTo(e.position)})}),t.sort((e,n)=>e.distance-n.distance),t},window.findNearestBlackHole=function(){const e=window.findBlackHoles();return e.length>0?e[0]:null},window.findNearestNebula=function(){const e=window.findNebulas();return e.length>0?e[0]:null},window.showCosmicStats=function(){const e=window.findCosmicObjects();return e.blackholes.length>0&&e.blackholes.forEach((e,n)=>{}),e.nebulas.length>0&&e.nebulas.forEach((e,n)=>{}),e},window.flyToPosition=function(e,t=200){if(!window.controls)return;const o=(new THREE.Vector3).subVectors(n.position,e).normalize(),i=e.clone().add(o.multiplyScalar(t));n.position.copy(i),window.controls.target.copy(e),window.controls.update()},window.flyToNearestBlackHole=function(){const e=window.findNearestBlackHole();e&&window.flyToPosition(e.position,300)},window.flyToNearestNebula=function(){const e=window.findNearestNebula();e&&window.flyToPosition(e.position,500)},window.getDiscoveredPlanetsCount=function(){return window.findAudioPlanets().filter(e=>e.discovered).length},window.listAllAudioPlanets=function(){const e=window.findAudioPlanets(),n=["","Tletl (Fire)","ƒÄtl (Water)","Tlalli (Earth)","Ehecatl (Wind)","Tonatiuh (Sun)"];return e.forEach((e,t)=>{e.discovered,n[e.planetId]||e.planetId}),e},window.flyToAudioPlanet=function(e){const n=window.findAudioPlanets().find(n=>n.planetId===e);if(n){window.flyToPosition(n.position,150)}},window.showFullStats=function(){const e=window.findCosmicObjects(),n=window.findAudioPlanets(),t=n.filter(e=>e.discovered).length;return{cosmic:e,planets:n,discovered:t}},window.clearConsole=function(){o()}}(ze,Te,Ge),function e(){Se.begin();const n=un.getDelta(),t=Math.min(n,.1),o=un.getElapsedTime();Ye.animate(),Ge.update(),nn.update(),o-an>=sn.spawnInterval&&(an=o,rn.push(new pe(ze,Te,sn))),rn.forEach((e,n)=>{e.update(t)||(ze.remove(e.mesh),rn.splice(n,1))}),function({timeParams:e,sunLight:n,moonLight:t,moonMesh:o,earthMesh:i,cloudParams:r,lensFlareEffect:s,backgroundMaterial:l,userLat:c,userLon:u,deltaTime:h,solarSystemOffset:p=new a(0,0,0)}){var f,v,g,w,y,b,x,M,C;let k;e.realTime?k=new Date:(k=new Date,k.setHours(e.hour,e.minute,e.second));const D=te.getPosition(k,c,u),S=1e3*Math.sin(D.altitude),P=1e3*Math.cos(D.altitude);n.position.set(Math.sin(D.azimuth)*P+p.x,S+p.y,Math.cos(D.azimuth)*P+p.z);const z=te.getMoonPosition(k,c,u),A=200*Math.sin(z.altitude),T=200*Math.cos(z.altitude);t.position.set(Math.sin(z.azimuth)*T+p.x,A+p.y,Math.cos(z.azimuth)*T+p.z),(null==o?void 0:o.position)&&o.position.copy(t.position);let R=new a;(null==i?void 0:i.getWorldPosition)?i.getWorldPosition(R):R.copy(p);const H=n.position.clone().sub(R).normalize();if(null==(v=null==(f=null==o?void 0:o.material)?void 0:f.uniforms)?void 0:v.lightDirection){let e=new a;o.getWorldPosition?o.getWorldPosition(e):e.copy(t.position);const i=n.position.clone().sub(e).normalize();o.material.uniforms.lightDirection.value.copy(i)}(null==(w=null==(g=null==i?void 0:i.userData)?void 0:g.earthUniforms)?void 0:w.lightDirection)&&i.userData.earthUniforms.lightDirection.value.copy(H);const E=te.getMoonIllumination(k);if((null==(b=null==(y=null==o?void 0:o.material)?void 0:y.uniforms)?void 0:b.moonIllumination)&&(o.material.uniforms.moonIllumination.value=E.fraction),i){const e=2*Math.PI/86400*h;if(i.rotation.y+=e,i.rotation.z=m.degToRad(-23.4),null==(x=i.userData)?void 0:x.cloudUniforms){const e=i.userData.cloudUniforms;e.lightDirection&&e.lightDirection.value.copy(H);const n=null==r?void 0:r.speed,t=(null==r?void 0:r.direction)??new d(1,.05);e.cloudSpeed&&(e.cloudSpeed.value=n),e.cloudDirection&&(e.cloudDirection.value=t)}}D.altitude,n.visible=!0,t.visible=!0,o&&(o.visible=!0),s.visible=!0,(null==(C=null==(M=null==s?void 0:s.material)?void 0:M.uniforms)?void 0:C.isDaytime)&&(s.material.uniforms.isDaytime.value=!0),n.intensity=1.2,t.intensity=.8,k.getHours(),k.getMinutes()}({timeParams:tn,sunLight:Ve,moonLight:Be,moonMesh:Ze,earthMesh:Ke,cloudParams:on,lensFlareEffect:en,backgroundMaterial:null,userLat:40.96,userLon:29.08,deltaTime:t*tn.simulationSpeed,solarSystemOffset:ue}),cn.update(t),qe.update(),$e.update(t),Ne.update(),He.update(t),Re.update();const i=Te.position;ln.x=i.x.toFixed(2),ln.y=i.y.toFixed(2),ln.z=i.z.toFixed(2);const r=function(e,n){const t=function(e){return e.getTime()/864e5+2440587.5}(e),o=(t-2451545)/36525;let i=280.46061837+360.98564736629*(t-2451545)+387933e-9*o*o-o*o*o/3871e4;return i=(i%360+360)%360,((i+n)%360+360)%360}(new Date,29.08),s=i.length(),l=Math.asin(i.y/s),c=Math.atan2(i.z,i.x),u=(m.degToRad(r)-c+2*Math.PI)%(2*Math.PI)/(2*Math.PI)*24,h=Math.floor(u),p=Math.floor(60*(u-h)),f=m.radToDeg(l);ln.ra=`${h}h ${p}m`,ln.dec=`${f.toFixed(2)}¬∞`,Ee.render(),Se.end(),requestAnimationFrame(e)}(),window.addEventListener("resize",()=>{Te.aspect=window.innerWidth/window.innerHeight,Te.updateProjectionMatrix(),Ae.setSize(window.innerWidth,window.innerHeight),Ee.setSize(window.innerWidth,window.innerHeight),Ne.updateAspectRatio()});
